#' Restrict a model
#'
#' Restrict causal types. If priors exist, prior probabilities are redistributed over remaining types.
#'
#' @param model A model object generated by \code{make_model()}.
#' @param node_restrict A list of character vectors specifying nodal types to be kept or removed from the model. Use \code{get_nodal_types} to see syntax.
#' @param causal_type_restrict  A quoted expressions defining the restriction
#' @param join_by A string. The logical operator joining expanded types when \code{causal_type_restrict} contains wildcard (\code{.}). Can take values \code{"&"} (logical AND) or \code{"|"} (logical OR). When restriction contains wildcard (\code{.}) and \code{join_by} is not specified, it defaults to \code{"|"}, otherwise it defaults to \code{NULL}.
#' @param keep Logical. If `FALSE`, removes and if `TRUE` keeps only causal types specified by \code{causal_type_restrict} and/or \code{node_restrict}.
#' @export
#' @return A model with restrictions and nodal types saved as attributes.
#'
#' @examples
#' # Restrictions can be specified in of the the three following ways:
#' # 1. Using nodal_types syntax:
#' require(dplyr)
#'
#' # Restrict parameter space using nodal types
#' model <- make_model("X->Y") %>%
#' set_restrictions(node_restrict = list(X = "X0", Y = "Y00"))
#' get_parameter_matrix(model)
#' # Restrict to a single type
#' model <- make_model("X->Y") %>%
#' set_restrictions(node_restrict = list(X = "X0", Y = c("Y00", "Y01", "Y11")))
#' get_parameter_matrix(model)
#' # Restrict to a single type
#' model <- make_model("X->Y") %>%
#' set_restrictions(node_restrict = list(Y = "Y11"), keep = TRUE)
#' get_parameter_matrix(model)
#' # Restrictions can be  with wildcards
#' model <- make_model("X->Y") %>%
#' set_restrictions(node_restrict = list(Y = "Y?0"))
#' get_parameter_matrix(model)
#' # Running example: there are only four causal types
#' model <- make_model("S -> C -> Y <- R <- X; X -> C -> R") %>%
#' set_restrictions(node_restrict = list(C = "C1000", R = "R0001", Y = "Y0001"), keep = TRUE)
#' get_parameter_matrix(model)
#'
#' # Restrict parameter space using casual types
#' model <- make_model("X->Y") %>%
#' set_restrictions(causal_type_restrict = c("X == 0", "Y==0"))
#' get_parameter_matrix(model)
#' # Restrict to define a model with monotonicity
#' model <- make_model("X->Y") %>%
#' set_restrictions(causal_type_restrict = c("Y[X=1] < Y[X=0]"))
#' get_parameter_matrix(model)
#' # Restriction with a wildcard
#' model <- make_model("X->Y<-M") %>%
#' set_restrictions(causal_type_restrict = c("(Y[X=1, M=.] < Y[X=0, M=.])"), join_by = "&")
#' get_parameter_matrix(model)
#' # Restrict to a single type in endogenous variable
#' model <- make_model("X->Y") %>%
#' set_restrictions(causal_type_restrict =  "(Y[X=.] == 1)", join_by = "&", keep = TRUE)
#' get_parameter_matrix(model)
set_restrictions <- function(model,
														 statement = NULL,
														 join_by = "|",
														 labels = NULL,
														 keep = FALSE){

	if(!is.logical(keep)) stop("`keep` should be either 'TRUE' or 'FALSE'")
	if(is.null(labels) & is.null(statement) ) {message("No restrictions provided."); return(model)}

	if(is.null(statement)){
		model <- restrict_nodal_types_labels(model,
																				 labels = labels,
																				 keep = keep)
	} else{
		model <- restrict_nodal_types_labels(model,
																				 statement =statement,
																				 join_by = join_by,
																				 keep = keep)
	}

	return(model)
}
#' Reduce nodal types
#' @param model a model created by make_model()
#' @param restriction a list of character vectors specifying nodal types to be removed from the model. Use \code{get_nodal_types} to see syntax.
#' @param keep Logical. If `FALSE`, removes and if `TRUE` keeps only causal types specified by \code{restriction}.
restrict_nodal_types_exp <- function(model,
																		 statement,
																		 join_by = "|",
																		 keep = FALSE){

	nodal_types <- get_nodal_types(model)
	n_restrictions <- length(statement)

	if(!is.logical(keep)) stop("`keep` should be either 'TRUE' or 'FALSE'")


	restrict_expression <- function(statement, join_by, m = model , k = keep, nt = nodal_types){

		selected_types   <- lookup_type(m, query = statement, join_by = join_by)
		restriction_list <- names(selected_types$types)[selected_types$types]
		node             <- selected_types$node
		nodal_types_var <- nt[[node]]
		if(k){
			ret_list <- list(types = nodal_types_var[nodal_types_var %in% restriction_list],
											 node  = node)
		}
		else{
			ret_list <- list(types = nodal_types_var[!nodal_types_var %in% restriction_list],
											 node  = node)
		}
		return(ret_list)
	}

	# WIP
	if(n_restrictions == 1){
		restricted_types <- 	restrict_expression(statement, join_by)
		nodal_types[[restricted_types$node]] <- restricted_types$types
	} else if(	n_restrictions > 1){
		if(length(join_by) == 1){
			join_by <- rep(join_by, n_restrictions)

		} else if(length(join_by) != n_restrictions){
			stop(paste0("Argument `join_by` must be either of length 1 or have the same lenght as `restriction` argument."))
		}
	}

	model$nodal_types         <- nodal_types

	# Subset priors
	type_names          <- gbiqq:::get_type_names(nodal_types)
	if(!is.null(model$priors))
		model$priors <- model$priors[type_names]
	if(!is.null(model$parameters)) model$parameters <-
		reduce_parameters(model, model$parameters)
	return(model)
}


#' Reduce nodal types
#' @param model a model created by make_model()
#' @param restriction a list of character vectors specifying nodal types to be removed from the model. Use \code{get_nodal_types} to see syntax.
#' @param keep Logical. If `FALSE`, removes and if `TRUE` keeps only causal types specified by \code{restriction}.
restrict_nodal_types_labels <- function(model, labels, keep = FALSE){

	variables   <- model$variables
	nodal_types <- get_nodal_types(model)


	# Stop if none of the names of the labels vector matches variables in dag
	# Stop if there's any restriction name that doesn't match any of the variables in the dag
	restricted_vars <- names(restriction)
	matches    <- restricted_vars %in% variables
	if(!any(matches)){
		stop("labels don't match variables in DAG")
	} else if(any(!matches)){
		stop("Variables ", paste(names(restriction[!matches ]) ,"are not part of the model."))
	}

	# If there are wild cards, spell them out
	restriction_list <- lapply(restriction, function(j) unique(unlist(sapply(j, unpack_wildcard))))

	# If "keep" specified, reverse meaning of restricted types -- only stipulated types to be kept
	if(!is.logical(keep)) stop("`keep` should be either 'TRUE' or 'FALSE'")
	if(keep) for(j in names(restriction)){

		restriction_list <-
			sapply(names(restriction_list), function(j){
				nodal_types[[j]][!(nodal_types[[j]] %in% restriction_list[[j]])]
			}, simplify = FALSE)

	}
	nodal_types_labels <- nodal_types[restricted_vars]


	# Paste vars to labels when needed
	# For flexibility, labels can be written as "0" or "X0" for an exogenous var X
	# Though, we'd write its nodal_types as "X0" or "X1"
	# length(labels) = n_vars for which labels were specified
	labels_out <- lapply(1:length(restriction_list), function(i){

		#Identify nodal_types, var name and actual restriction statement for the current restriction
		ntr <- nodal_types_labels[[i]]
		restricted_var <- restricted_vars[i]
		labels_i <- restriction_list[[i]]
		if(length(ntr) == length(labels_i)) {
			stop(paste0("nodal_types can't be entirely reduced. Revise labels for variable ", restricted_var))
		}
		# Run through vector of labels for current restricted variable
		labels_i <- sapply(1:length(labels_i), function(j){
			restriction_ij <- labels_i[j]
			# if restriction doesn't contain variable's name
			# it pastes restricted var to restriction
			restriction_ij <- ifelse(grepl(restricted_var, restriction_ij),
															 restriction_ij,
															 paste0(restricted_var, restriction_ij))
			#  stop if restriction doesn't conform to nodal_types syntax (i.e. it doesn't look like Y00)
			#			if(!restriction_ij  %in% ntr){stop(paste0("Restriction ",	restriction_ij, " not conformable to nodal_types"))}
			# and return labels if it does.
			restriction_ij})

		## Nodal types are reduced here!
		nodal_types[[restricted_var]] <<- ntr[!ntr %in% labels_i]
		labels_i
	})

	names(labels_out)   <- restricted_vars
	model$nodal_types         <- nodal_types

	# Subset priors
	type_names          <- gbiqq:::get_type_names(nodal_types)
	if(!is.null(model$priors))
		model$priors <- model$priors[type_names]
	if(!is.null(model$parameters)) model$parameters <-
		reduce_parameters(model, model$parameters)
	return(model)
}


#' Reduce parameters
#' If parameters is longer than nodel types, because of a model restriction, subset lambda and renormalize
#' @param model a model created by make_model()
#' @param parameters a parameter vector possibly longer than the parameter length expected by model
#' @export

reduce_parameters <- function(model, parameters = model$parameters){

	variables   <- model$variables
	nodal_types <- get_nodal_types(model)
	type_names  <- get_type_names(nodal_types)
	parameters  <- parameters[type_names]

	parameters <-
		unlist(sapply(variables, function(v){
			i <- which(startsWith(names(parameters), paste0(v, ".")))
			parameters[i]/sum(parameters[i])}, USE.NAMES = FALSE))

	parameters
}


#' Get type names
#' @param nodal_types Nodal types of a model. See \code{get_nodal_types()}.
#'
get_type_names <- function(nodal_types) {
	unlist(sapply(1:length(nodal_types), function(i){
		name <- names(nodal_types)[i]
		a    <- nodal_types[[i]]
		paste(name, a, sep =".")
	}))}


#' Unpack a wild card
#' @param x A string of length 1L. A nodal type containing one or more wildcard characters "." to be unpacked.

unpack_wildcard <- function(x) {
	splitstring <- strsplit(x, "")[[1]]
	n_wild <- sum(splitstring=="?")
	if(n_wild ==0) return(x)
	variations <- perm(rep(1, n_wild))
	apply(variations, 1, function(j)  {
		z <- splitstring
		z[z=="?"] <- j
		paste0(z, collapse = "")})}

