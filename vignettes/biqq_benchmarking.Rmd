---
title: "Biqq likelihoods"
output: 
  html_document:
    toc: true 
    toc_depth: 3 
    number_sections: true 
    theme: united
    highlight: tango  
---

```{r,include=FALSE}
rm(list = ls())
library(gbiqq)
library(knitr)
library(dplyr)
```

# Intro

Canonical "grounded" BIQQ model: $X \rightarrow K, Y$ and $K \rightarrow Y$.

Data: counts of all possibly observable data events $d_{XKY}$, generated by multinomial process with probability vector $w$ of same length as $d$

Parameters: $\pi$ - distribution over domain of exogenous variable given type space of terminal node of its children; $\lambda$ proportions of causal types of endogenous variables.  

Point of this document: compare likelihood for $d_{XKY}$ in three approaches:
  1. `biqq_lower` that aggregates up to higher level DAG (ABCD types) and uses "traditional" likelihood
  2. `biqq_loop` that uses a loop to generate lower-level likelihood
  3. `biqq_matrix` that uses matrix algebra to generate lower-level likelihood
  
Procedure used here: pull out the stan code used to generate $w$, make it a function, compare results across different values of $\pi$ and $\lambda$. 
  
# Functions

## BIQQ Lower

```{r}
biqq_lower <- function(lambda_Y,lambda_K,pi){
	abcd <- rep(0,4)
	w_XY <- rep(0,4)
	w_XYK <- rep(0,8)

	names(w_XYK) <- c( "X = 0,Y = 0,K = 0",
										 "X = 0,Y = 0,K = 1",
										 "X = 0,Y = 1,K = 0",
										 "X = 0,Y = 1,K = 1",
										 "X = 1,Y = 0,K = 0",
										 "X = 1,Y = 0,K = 1",
										 "X = 1,Y = 1,K = 0",
										 "X = 1,Y = 1,K = 1")
	abcd[1] = (
		(lambda_Y[9]+lambda_Y[10]+lambda_Y[13]+lambda_Y[14])*lambda_K[1]+
			(lambda_Y[9]+lambda_Y[11]+lambda_Y[13]+lambda_Y[15])*lambda_K[2]+
			(lambda_Y[5]+lambda_Y[6] +lambda_Y[13]+lambda_Y[14])*lambda_K[3]+
			(lambda_Y[5]+lambda_Y[7] +lambda_Y[13]+lambda_Y[15])*lambda_K[4]
	);
	abcd[2] = (
		(lambda_Y[3]+lambda_Y[4]+lambda_Y[7]+lambda_Y[8])*lambda_K[1]+
			(lambda_Y[2]+lambda_Y[4]+lambda_Y[6]+lambda_Y[8])*lambda_K[2]+
			(lambda_Y[3]+lambda_Y[4]+lambda_Y[11]+lambda_Y[12])*lambda_K[3]+
			(lambda_Y[2]+lambda_Y[4]+lambda_Y[10]+lambda_Y[12])*lambda_K[4]
	) ;
	abcd[3] = (
		(lambda_Y[1]+lambda_Y[2]+lambda_Y[5]+lambda_Y[6])* lambda_K[1]+
			(lambda_Y[1]+lambda_Y[3]+lambda_Y[5]+lambda_Y[7])* lambda_K[2]+
			(lambda_Y[1]+lambda_Y[2]+lambda_Y[9]+lambda_Y[10])*lambda_K[3]+
			(lambda_Y[1]+lambda_Y[3]+lambda_Y[9]+lambda_Y[11])*lambda_K[4]
	);
	abcd[4] = (
		(lambda_Y[11]+lambda_Y[12]+lambda_Y[15]+lambda_Y[16])*lambda_K[1]+
			(lambda_Y[10]+lambda_Y[12]+lambda_Y[14]+lambda_Y[16])*lambda_K[2]+
			(lambda_Y[7] +lambda_Y[8] +lambda_Y[15]+lambda_Y[16])*lambda_K[3]+
			(lambda_Y[6] +lambda_Y[8] +lambda_Y[14]+lambda_Y[16])*lambda_K[4]
	);



	pi_a = (
		(lambda_Y[9]*pi[9,1] + lambda_Y[10]*pi[10,1] + lambda_Y[13]*pi[13,1] + lambda_Y[14]*pi[14,1])*lambda_K[1] +
			(lambda_Y[9]*pi[9,2] + lambda_Y[11]*pi[11,2] + lambda_Y[13]*pi[13,2] + lambda_Y[15]*pi[15,2])*lambda_K[2] +
			(lambda_Y[5]*pi[5,3] + lambda_Y[6]*pi[6,3]   + lambda_Y[13]*pi[13,3] + lambda_Y[14]*pi[14,3])*lambda_K[3] +
			(lambda_Y[5]*pi[5,4] + lambda_Y[7]*pi[7,4]   + lambda_Y[13]*pi[13,4] + lambda_Y[15]*pi[15,4])*lambda_K[4])/abcd[1];

	pi_b = (
		(lambda_Y[3]*pi[3,1] + lambda_Y[4]*pi[4,1] + lambda_Y[7]*pi[7,1]   + lambda_Y[8]*pi[8,1])*lambda_K[1] +
			(lambda_Y[2]*pi[2,2] + lambda_Y[4]*pi[4,2] + lambda_Y[6]*pi[6,2]   + lambda_Y[8]*pi[8,2])*lambda_K[2] +
			(lambda_Y[3]*pi[3,3] + lambda_Y[4]*pi[4,3] + lambda_Y[11]*pi[11,3] + lambda_Y[12]*pi[12,3])*lambda_K[3] +
			(lambda_Y[2]*pi[2,4] + lambda_Y[4]*pi[4,4] + lambda_Y[10]*pi[10,4] + lambda_Y[12]*pi[12,4])*lambda_K[4])/abcd[2];


	pi_c = (
		(lambda_Y[1]*pi[1,1] + lambda_Y[2]*pi[2,1] + lambda_Y[5]*pi[5,1]  + lambda_Y[6]*pi[6,1])*lambda_K[1] +
			(lambda_Y[1]*pi[1,2] + lambda_Y[3]*pi[3,2] + lambda_Y[5]*pi[5,2]  + lambda_Y[7]*pi[7,2])*lambda_K[2] +
			(lambda_Y[1]*pi[1,3] + lambda_Y[2]*pi[2,3] + lambda_Y[9]*pi[9,3]  + lambda_Y[10]*pi[10,3])*lambda_K[3] +
			(lambda_Y[1]*pi[1,4] + lambda_Y[3]*pi[3,4] + lambda_Y[9]*pi[9,4]  + lambda_Y[11]*pi[11,4])*lambda_K[4]
	)/abcd[3];

	pi_d = (
		(lambda_Y[11]*pi[11,1] + lambda_Y[12]*pi[12,1] + lambda_Y[15]*pi[15,1] + lambda_Y[16]*pi[16,1])*lambda_K[1] +
			(lambda_Y[10]*pi[10,2] + lambda_Y[12]*pi[12,2] + lambda_Y[14]*pi[14,2] + lambda_Y[16]*pi[16,2])*lambda_K[2] +
			(lambda_Y[7]*pi[7,3]   + lambda_Y[8]*pi[8,3]   + lambda_Y[15]*pi[15,3] + lambda_Y[16]*pi[16,3])*lambda_K[3] +
			(lambda_Y[6]*pi[6,4]   + lambda_Y[8]*pi[8,4]   + lambda_Y[14]*pi[14,4] + lambda_Y[16]*pi[16,4])*lambda_K[4]
	)/abcd[4];

	# u_K3 and U_K4
	phi_a_0 = (
		(lambda_Y[5]*(1-pi[5,3])  + lambda_Y[6]*(1-pi[6,3])  +  lambda_Y[13]*(1-pi[13,3])  + lambda_Y[14]*(1-pi[14,3]))*lambda_K[3] +
			(lambda_Y[5]*(1-pi[5,4])  + lambda_Y[7]*(1-pi[7,4])  +  lambda_Y[13]*(1-pi[13,4])  + lambda_Y[15]*(1-pi[15,4]))*lambda_K[4]
	)/(abcd[1]*(1-pi_a));

	phi_b_0 = (
		(lambda_Y[3]*(1-pi[3,3])  + lambda_Y[4]*(1-pi[4,3]) +  lambda_Y[11]*(1-pi[11,3])   + lambda_Y[12]*(1-pi[12,3]))*lambda_K[3]+
			(lambda_Y[2]*(1-pi[2,4])  + lambda_Y[4]*(1-pi[4,4])  +  lambda_Y[10]*(1-pi[10,4])  + lambda_Y[12]*(1-pi[12,4]))*lambda_K[4]
	)/(abcd[2]*(1-pi_b));

	phi_c_0 = (
		(lambda_Y[1]*(1-pi[1,3])  +  lambda_Y[2]*(1-pi[2,3]) +  lambda_Y[9]*(1-pi[9,3])  +  lambda_Y[10]*(1-pi[10,3]))*lambda_K[3]+
			(lambda_Y[1]*(1-pi[1,4])  +  lambda_Y[3]*(1-pi[3,4])  +  lambda_Y[9]*(1-pi[9,4])  +  lambda_Y[11]*(1-pi[11,4]))*lambda_K[4]
	)/(abcd[3]*(1-pi_c));

	phi_d_0 = (
		(lambda_Y[7]*(1-pi[7,3])  +  lambda_Y[8]*(1-pi[8,3])  +  lambda_Y[15]*(1-pi[15,3])  +  lambda_Y[16]*(1-pi[16,3]))*lambda_K[3]+
			(lambda_Y[6]*(1-pi[6,4])  +  lambda_Y[8]*(1-pi[8,4])  +  lambda_Y[14]*(1-pi[14,4])  +  lambda_Y[16]*(1-pi[16,4]))*lambda_K[4]
	)/(abcd[4]*(1-pi_d));


	# u_K2 and U_K4
	phi_a_1 = ((lambda_Y[9]*(pi[9,2])  +  lambda_Y[11]*(pi[11,2])  +  lambda_Y[13]*(pi[13,2])  +  lambda_Y[15]*(pi[15,2]))*lambda_K[2]  +
						 	(lambda_Y[5]*(pi[5,4])  +  lambda_Y[7]*(pi[7,4])    +  lambda_Y[13]*(pi[13,4])  +  lambda_Y[15]*(pi[15,4]))*lambda_K[4] )/(abcd[1]*(pi_a));

	phi_b_1 = ((lambda_Y[2]*(pi[2,2])  +  lambda_Y[4]*(pi[4,2])  +  lambda_Y[6]*(pi[6,2])  +  lambda_Y[8]*(pi[8,2]))*lambda_K[2]  +
						 	(lambda_Y[2]*(pi[2,4])  +  lambda_Y[4]*(pi[4,4])    +  lambda_Y[10]*(pi[10,4])  +  lambda_Y[12]*(pi[12,4]))*lambda_K[4] )/(abcd[2]*(pi_b));

	phi_c_1 = ((lambda_Y[1]*(pi[1,2])  +  lambda_Y[3]*(pi[3,2])  +  lambda_Y[5]*(pi[5,2])  +  lambda_Y[7]*(pi[7,2]))*lambda_K[2]  +
						 	(lambda_Y[1]*(pi[1,4])  +  lambda_Y[3]*(pi[3,4])    +  lambda_Y[9]*(pi[9,4])  +  lambda_Y[11]*(pi[11,4]))*lambda_K[4] )/(abcd[3]*(pi_c));

	phi_d_1 = ((lambda_Y[10]*(pi[10,2])  +  lambda_Y[12]*(pi[12,2])  +  lambda_Y[14]*(pi[14,2])  +  lambda_Y[16]*(pi[16,2]))*lambda_K[2]  +
						 	(lambda_Y[6]*(pi[6,4])  +  lambda_Y[8]*(pi[8,4])    +  lambda_Y[14]*(pi[14,4])  +  lambda_Y[16]*(pi[16,4]))*lambda_K[4] )/(abcd[4]*(pi_d));



	w_XY[1] =  (1-pi_b)*abcd[2]          +(1-pi_c)*abcd[3]
	w_XY[2] =  (1-pi_a)*abcd[1]          +(1-pi_d)*abcd[4]
	w_XY[3] =  pi_a*abcd[1]              +pi_c*abcd[3]
	w_XY[4] =  pi_b*abcd[2]              +pi_d*abcd[4]


	w_XYK[1] =  (1-pi_b)*(1-phi_b_0)*abcd[2] +(1-pi_c)*(1-phi_c_0)*abcd[3] ;
	w_XYK[2] =  (1-pi_b)*phi_b_0*abcd[2]     +(1-pi_c)*phi_c_0*abcd[3]     ;

	w_XYK[3] =  (1-pi_a)*(1-phi_a_0)*abcd[1] +(1-pi_d)*(1-phi_d_0)*abcd[4] ;
	w_XYK[4] =  (1-pi_a)*phi_a_0*abcd[1]     +(1-pi_d)*phi_d_0*abcd[4]     ;

	w_XYK[5] =  pi_a*(1-phi_a_1)*abcd[1]     +pi_c*(1-phi_c_1)*abcd[3]     ;
	w_XYK[6] =  pi_a*phi_a_1*abcd[1]         +pi_c*phi_c_1*abcd[3]         ;

	w_XYK[7] =  pi_b*(1-phi_b_1)*abcd[2]     +pi_d*(1-phi_d_1)*abcd[4]     ;
	w_XYK[8] =  pi_b*phi_b_1*abcd[2]         +pi_d*phi_d_1*abcd[4]         ;

	# Here is a bunch of jazz to get it back into a comparable order
	reorder_mat <- rbind(
		data.frame(X = 0,K = 0,Y = 0),
		data.frame(X = 0,K = 1,Y = 0),
		data.frame(X = 0,K = 0,Y = 1),
		data.frame(X = 0,K = 1,Y = 1),
		data.frame(X = 1,K = 0,Y = 0),
		data.frame(X = 1,K = 1,Y = 0),
		data.frame(X = 1,K = 0,Y = 1),
		data.frame(X = 1,K = 1,Y = 1)
	)
	reorder_mat$w <- w_XYK
	reorder_mat$data_event <- with(reorder_mat,paste0("X",X,",K",K,",Y",Y))
	reorder_mat <- dplyr::arrange(reorder_mat,data_event)
	w <- reorder_mat$w
	names(w) <- reorder_mat$data_event
	return(w)
}

```


## BIQQ Loop

```{r}

biqq_loop <- function(lambda_Y,lambda_K,pi){
	# Taken from implement_biqq_ABCD_from_primitives
	# Generate matrix of types
	causal_type <- function(iK, iY){
		Y0 <- lambda_Y_types[iY, 1 + lambda_K_types[iK,1]]     #X=0, K= K(0)
		Y1 <- lambda_Y_types[iY, 3 + lambda_K_types[iK,2]]
		type <- 1 + (Y0 + 2*Y1)
		(c(3,1,2,4))[type]
	}
	lambda_Y_types <- matrix(perm(rep(2,4)), 16, 4)
	lambda_K_types <- matrix(perm(rep(2,2)), 4, 2)
	types <- t(sapply(1:16, function(iY){sapply(1:4, function(iK) {causal_type(iK, iY)})} ))

	# Parameters
	w_XKY <- rep(0,8)

	for (i in 1:16) {
		for (j in 1:2)  {
			# // X = 0, K = 0, Y = 0
			if (types[i,j] == 2  || types[i,j] == 3 ) w_XKY[1] = w_XKY[1] + (lambda_Y[i]*(1-pi[i,j])*lambda_K[j]);

			# // X = 0, K = 1, Y = 0
			if(types[i,j] == 1  || types[i,j] == 4 ) w_XKY[3] = w_XKY[3] + (lambda_Y[i]*(1-pi[i,j])*lambda_K[j]);

			# // X = 1, K = 0, Y = 0
			if(types[i,j] == 1  || types[i,j] == 3 )  w_XKY[5]  =  w_XKY[5] + (lambda_Y[i]*(pi[i,j])*lambda_K[j]);

			# // X = 1, K = 0 , Y = 1
			if(types[i,j] == 2  || types[i,j] == 4 ) w_XKY[7]  =  w_XKY[7] + (lambda_Y[i]*(pi[i,j])*lambda_K[j]);
		}

		for (j in 3:4)  {
			# // X = 0, K = 0, Y = 1
			if(types[i,j] == 2  || types[i,j] == 3 ) w_XKY[2] = w_XKY[2] + (lambda_Y[i]*(1-pi[i,j])*lambda_K[j]);

			# // X = 0, K = 1, Y = 1
			if(types[i,j] == 1  || types[i,j] == 4 ) w_XKY[4]  =  w_XKY[4] + (lambda_Y[i]*(1-pi[i,j])*lambda_K[j]);

			# // X = 1, K = 1, Y = 0
			if(types[i,j] == 1  || types[i,j] == 3 ) w_XKY[6]  =  w_XKY[6] + (lambda_Y[i]*(pi[i,j])*lambda_K[j]);

			# // X = 1, K = 1, Y = 1
			if(types[i,j] == 2  || types[i,j] == 4 ) w_XKY[8]  =  w_XKY[8] + (lambda_Y[i]*(pi[i,j])*lambda_K[j]);
		}}

	# Here is a bunch of jazz to get it back into a comparable order
	reorder_mat <- rbind(
		data.frame(X = 0,K = 0,Y = 0),
		data.frame(X = 0,K = 1,Y = 0),
		data.frame(X = 1,K = 0,Y = 0),
		data.frame(X = 1,K = 0,Y = 1),
		data.frame(X = 0,K = 0,Y = 1),
		data.frame(X = 0,K = 1,Y = 1),
		data.frame(X = 1,K = 1,Y = 0),
		data.frame(X = 1,K = 1,Y = 1)
	)
	reorder_mat$w <- w_XKY
	reorder_mat$data_event <- with(reorder_mat,paste0("X",X,",K",K,",Y",Y))
	reorder_mat <- dplyr::arrange(reorder_mat,data_event)
	w <- reorder_mat$w
	names(w) <- reorder_mat$data_event
	return(w)
}

```

## BIQQ Matrix

Our matrix-based approach to the BIQQ likelihood is part of the attempt to generalize BIQQ to arbitrary DAGS. 

The basic idea:
	
- every DAG has one or more exogenous variables (here, $X$)
- every DAG as one or more endogenous variables (here, $K,Y$)
- every DAG has an endogenous variable that is a terminal node (here, $Y$)
- every path from an exogenous variable to a terminal node contains:
	- an exogenous parent
	- one or more children
	- the terminal node
- given the variables and their domains, there is a known set of data events, including those events in which subsets of the data are not observed  

Using this information:

- for each terminal node, provide dirichlet priors over all causal types that can generate the terminal node (i.e. $\lambda_Y$) and all of its endogenous parents (i.e. $\lambda_K$), and take the cartesian product of the types (i.e. ($(\lambda_Y\mid t_Y = 1 \times \lambda_K \mid t_K = 1)...(\lambda_Y \mid t_Y = 16 \times \lambda_K \mid t_K = 4)$) to generate a single vector $\lambda$ 
- for each pathway from an exogenous variable to a terminal node, provide a vector of beta priors $\pi$ that associate with each combination of children types the probability that the exogenous variable is 1 (i.e. $(Pr(X = 1) \mid t_Y = 1,t_K = 1)...(Pr(X = 1) \mid t_Y = 16,t_K = 4)$)
- build a matrix, $\Pi$ from $\pi$ and the observable data events, whose columns correspond to the endogenous types and whose rows correspond to the data events ($\pi$ or $1-\pi$), so that if $d[1] = 000$ and $d[8] = 111$, $\Pi[1,64] = Pr(X = 0 \mid t_Y = 16, t_K =4)$ and $\Pi[8,64] = Pr(X = 1 \mid t_Y = 16, t_K = 4)$. 
- build a matrix, $A$, that has as many rows as data events and as many columns as endogenous types. Cell $A[i,j]$ has a 1 if the $i$'th data event could have been generated by the $j$'th combination of endogenous types, and 0 otherwise. 

We build these things below using functions from the private `gbiqq` (generalized BIQQ) package we're working from for the moment. It's all still shifting around but gets the basic concept across. 

```{r}
dag <- gbiqq::make_dag(add_edges(parent = "X",children = c("K", "Y")),
											 add_edges(parent = c("K"),children = "Y"))

kable(dag)

# our types look as follows:
gbiqq::get_types(dag)

# Note these are in the same order as the types created in implement_biqq_ABCD_from_primitives.R
(lambda_Y_types <- matrix(perm(rep(2,4)), 16, 4))
(lambda_K_types <- matrix(perm(rep(2,2)), 4, 2))

# Make the A matrix
A <- gbiqq::collapse_ambiguity_matrices(dag)$K_Y

kable(A[1:8,1:5])
kable(A[1:8,59:64])

# These are the values of X in the order of the likelihood we are using
(exogenous_value <- rep(c(0,0,1,1),2))

```

Eventually the entire likelihood for arbitrary DAGs should be expressed in a few short lines (we hope). There are many complications arising from more complicated DAGs that we are working through (multiple terminal nodes, multiple exogenous variables, complicated pathways involving multiple non-terminal children, etc.), and this is maintaining some strong restrictions (binary variables, no correlations between exogenous variables, etc.). Watch this space.

```{r}
biqq_matrix <- function(lambda_Y,lambda_K,pi){
	# Likelihood:
	lambda <- matrix(t(lambda_K) %*% lambda_Y,nrow = 1)
	pi_1 <- matrix(t(pi),nrow = 1)
	pi_0 <- 1-pi_1
	pi_new <- exogenous_value %*% pi_1 + (1 - exogenous_value) %*% pi_0
	w_XKY <- lambda %*% t(A*pi_new)

	# Here is a bunch of jazz to get it back into a comparable order
	reorder_mat <- rbind(
		data.frame(X = 0,K = 0,Y = 0),
		data.frame(X = 0,K = 0,Y = 1),
		data.frame(X = 1,K = 0,Y = 0),
		data.frame(X = 1,K = 0,Y = 1),
		data.frame(X = 0,K = 1,Y = 0),
		data.frame(X = 0,K = 1,Y = 1),
		data.frame(X = 1,K = 1,Y = 0),
		data.frame(X = 1,K = 1,Y = 1)
	)
	reorder_mat$w <- as.vector(w_XKY)
	reorder_mat$data_event <- with(reorder_mat,paste0("X",X,",K",K,",Y",Y))
	reorder_mat <- dplyr::arrange(reorder_mat,data_event)
	w <- reorder_mat$w
	names(w) <- reorder_mat$data_event
	return(w)
}


```



# Benchmarking 

Now let's try giving the likelihood approaches some simple cases to deal with. 

Here we have flat priors over $\lambda_Y$ but we rule out situations in which $K = 1$ if $X = 1$. Flat priors over $X$. 

```{r}
lambda_Y <- matrix(rep(1,16),nrow = 1)
(lambda_Y <- lambda_Y/sum(lambda_Y))
lambda_K <- matrix(c(1,0,1,0),nrow = 1)
(lambda_K <- lambda_K/sum(lambda_K))
(pi <- matrix(data = rep(.5, 16 * 4 ), nrow = 16))
```

A priori we should expect our likelihood to reflect the fact that: $(XKY) = (110)$ and $(XKY) = (111)$ can never happen, and that $(XKY) = (101)$ and $(XKY) = (100)$ are more likely than the other events because $K$ is always 0 whenever $X=1$, but only half the time when $X = 0$.

```{r}
biqq_lower(lambda_Y = lambda_Y,lambda_K = lambda_K, pi = pi)
biqq_loop(lambda_Y = lambda_Y,lambda_K = lambda_K, pi = pi)
biqq_matrix(lambda_Y = lambda_Y,lambda_K = lambda_K, pi = pi)
```

`biqq_loop` appears to get it wrong.

Now let's try ruling out situations in which $K = 0$ when $X = 0$. 

```{r}
lambda_K <- matrix(c(0,0,1,1),nrow = 1)
lambda_K <- lambda_K/sum(lambda_K)
biqq_lower(lambda_Y = lambda_Y,lambda_K = lambda_K, pi = pi)
biqq_loop(lambda_Y = lambda_Y,lambda_K = lambda_K, pi = pi)
biqq_matrix(lambda_Y = lambda_Y,lambda_K = lambda_K, pi = pi)
```

Loop appears to get it wrong. Flat priors over lambdas, X is always 1:

```{r}
lambda_K <- matrix(c(1,1,1,1),nrow = 1)
lambda_K <- lambda_K/sum(lambda_K)
pi <- matrix(data = rep(1, 16 * 4 ), nrow = 16)
biqq_lower(lambda_Y = lambda_Y,lambda_K = lambda_K, pi = pi)
biqq_loop(lambda_Y = lambda_Y,lambda_K = lambda_K, pi = pi)
biqq_matrix(lambda_Y = lambda_Y,lambda_K = lambda_K, pi = pi)
```

Lower appears to be getting it right but is dividing by 0s somewhere, loop breaks, matrix gets it right. 



















