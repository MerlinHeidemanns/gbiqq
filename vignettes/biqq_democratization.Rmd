---
title: "A lower-level model of democratization"
author: "biqq Team"
date: "October 30, 2018"
output: html_document
---

```{r setup, include=FALSE}
require(rstan)
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores())
# To avoid recompilation of unchanged Stan programs, we recommend calling
rstan_options(auto_write = TRUE)
```

# A model of democratization

We apply the gBIQQ framework to estimate the causal linkage between inequality (I) and democratization (D). In our model we allow for direct effects of inequality on democratization, as well as effects running through a mediator: mobilization. Based on the work of Huntington (1993) and Litz and Stepan (1996), we include international pressure (P) as an exogenous variable that might directly affect democratization. The directed acyclyc graph below depicts these relationships.


```{r}
democratization_dag <-
	gbiqq::make_dag(add_edges(parent = "I", children = c("M", "D")),
									add_edges(parent = "M", children = c("D")),
									add_edges(parent = "P", children = c("D")))


plot_dag(democratization_dag)

```


# Data

For simplicity, we allow the variables in this model to take values 0 or 1. 
```{r}
N <- 100
data <- data.frame(
	I = rbinom(N,1, .8), # Inequality
	M = rbinom(N,1,.5),  # Mobilization
	P = rbinom(N,1,0.3), # International Pressure
  D = rbinom(N,1,.5))  # Democratization

```


# Defining priors

We now express our prior beliefs over our set of parameters $\theta :\{ \lambda, \pi\}$. The p $\lambda$ parameter represents the proportion of the population that for which a change in given treatment condition (e.g from I = 0, M = 1, P =1 to  I = 1, M = 1, P =1) would result in democratization (D = 1). $\pi$ represents the propabilty that a case is assigned to treatment.

```{r}

# M has 4 possible causal types
# a: inequality =0 --> M = 1 and I = 1 --> M =0
# b: inequality = 0 -> M=0 and I = 1-> M=1
# c: I= 0 -> M=0 and I = 1  M =0
# d I =0 -> M=1 and I= 1 -> M=1

# For Democartization the situation is somewhat more complicated; there are 3 variables affecting democratization P, I, and M. Each variable has two levels 1 and 0 2^3 = 8 and for each of those democaratization can be either 0 or 1 2^8=256

lambdas_prior <- lambdas <-
	do.call(c, 
	 lapply(gbiqq::get_n_endogenous_types(democratization_dag), 
		function(variable_types) {
  	 lambda <- rep(1/variable_types, times = variable_types)
	   return(lambda)
  	 }))


# pi priors in correct dimensionality
pis_prior <-
	do.call(c,
					lapply(
						lapply(gbiqq::get_children_of_exogenous(democratization_dag),
									 FUN = function(childs) gbiqq::get_n_endogenous_types(democratization_dag)[childs]),
						FUN = function(child_types) rep(.5, times = prod(child_types))
					)
	)

pis_prior <- cbind(pis_prior,pis_prior)

```



```{r}

# STAN Model --------------------------------------------------------------------------

# int<lower=1> K; // number of variables
# int<lower=1> K_endog; // number of endogenous variables
# int<lower=1> K_exog; // number of exogenous variables
# int<lower=1> N_endog_each[K_endog]; // number of types for each endogenous variable
# int<lower=1> N_types; // sum(N_endog_each)
# int<lower=1> N_events; // number of possible events
# int<lower=1> N_data; // number of possible data realizations
# int<lower=1> N_endog_expand; // prod(N_endog_each)
# matrix<lower=0,upper=1>[N_data,K] max_possible_data;
#
# // lambda data
# vector<lower=0>[N_types] dirichlet_prior;
# int<lower=1> l_starts[K_endog];
# int<lower=1> l_ends[K_endog];
#
# // pi data
# int<lower=1> N_exog_types; //
# real<lower=0> beta_prior[N_exog_types,2];
# int<lower=1> p_starts[K_exog];
# int<lower=1> p_ends[K_exog];
# int<lower=1> p_each[K_exog];
# int<lower=1> p_times[K_exog];
#
# // ambiguity data
# matrix<lower=0,upper=1>[N_data,N_endog_expand] A;
#
# // user data
# int<lower=0,upper=2147483647> Y[N_events]; // incorrect dimensionality, only for the tryout

```

```{r}

# preliminary
# likelihood_helpers
# w are the event probabilities defined in terms of lambda .
# Strategies? ---seems to be the exhaustive combinations of variables. Includes each of the variables as single and allone variables I;P;M;D..but also as a combination IM or ID  IMD.. variables that are not d-connected are not strategies. so it seems.....and the events related to estrategies IM I = 1 M =0 

likelihood_helpers <- get_likelihood_helpers(democratization_dag)
children_of_exogenous <- gbiqq::get_children_of_exogenous(democratization_dag)


K <- n <- length(gbiqq::get_variables(democratization_dag))
K_endog <- n_endog <-  length(gbiqq::get_endogenous_vars(democratization_dag))
K_exog <- n_exog <- length(gbiqq::get_exogenous_vars(democratization_dag))
N_endog_each <- n_endogenous_types <- gbiqq::get_n_endogenous_types(democratization_dag)
N_types <- n_lambdas <- sum(N_endog_each)
# for now, this is generally incorrect
N_events <- nrow(get_data_events(data = data, dag = democratization_dag)$data_events) #ocurrences of events in data
N_data <- nrow(gbiqq::get_max_possible_data(democratization_dag)) ##??
N_endog_expand <- prod(N_endog_each)
max_possible_data <- gbiqq::get_max_possible_data(democratization_dag)



# checks
stopifnot(dim(max_possible_data) == c(N_data,K))

### lambda data

dirichlet_prior <- lambdas_prior
l_starts <- cumsum(n_endogenous_types) - n_endogenous_types + 1
l_ends <- cumsum(n_endogenous_types)

# checks
stopifnot(any(length(dirichlet_prior) == N_types,
							length(l_starts) == K_endog,
							length(l_starts) == K_endog))

### pi data

# for the vector of vectors of draws from the prior distributions of pis
.p_temp <-
	sapply(
		lapply(children_of_exogenous,
					 FUN = function(childs) N_endog_each[childs]),
		FUN = function(child_types) prod(child_types)
	)


N_exog_each <- .p_temp
N_exog_types <- n_pis <- sum(.p_temp)
beta_prior <- pis_prior
p_starts <- cumsum(.p_temp) - .p_temp + 1
p_ends <- cumsum(.p_temp)

# for expanding this to conform with A and L
.p_temp <-
	get_pi_expanders(pi = lapply(children_of_exogenous,
															 FUN = function(childs) N_endog_each[childs]),
									 dag = democratization_dag)

p_times <- sapply(.p_temp, function(v) v$times)
p_each <- sapply(.p_temp, function(v) v$each)

# checks
stopifnot(any(length(dirichlet_prior) == N_types,
							length(p_starts) == K_exog,
							length(p_ends) == K_exog,
							length(l_starts) == K_exog,
							length(l_starts) == K_exog,
							length(N_exog_each) == K_exog))

### for A (ambiguity)

A <- gbiqq::expand_ambiguity_matrices(democratization_dag)


### for w (vector of vectors of weights) -- not implemented yet

w_starts <- likelihood_helpers$w_starts
w_ends <- likelihood_helpers$w_ends
A_w <- likelihood_helpers$A_w
K_strategies <- likelihood_helpers$n_strategies

### for Y (vector of data counts)

Y <- get_data_events(data = data, dag = democratization_dag)$data_events$count



```




```{r}

# WITHIN STAN Stuff -----------------------------------------------------------------------------------

gamma <- runif(N_types - K_endog, 0, 2)

lambdas_base <- rep(NA, N_types)
sum_gammas <- rep(NA, K_endog)
for (i in 1:K_endog) {
	sum_gammas[i] = 1 + sum(gamma[(l_starts[i] - (i - 1)):(l_ends[i] - i)]);
	lambdas_base[l_starts[i]:l_ends[i]] =
		c(1,gamma[(l_starts[i] - (i - 1)):(l_ends[i] - i)]) / sum_gammas[i];
}

# LAMBDAS STUFF
lambdas <- rep(NA, N_endog_expand) # no need to do this in STAN
expansion <- N_endog_each[K_endog]

lambdas[(N_endog_expand - expansion + 1):N_endog_expand] =
	lambdas_base[l_starts[K_endog]:l_ends[K_endog]]

endog_i <- K_endog - 1

while (endog_i > 0) {

	lambdas_temp <- rep(NA, expansion*N_endog_each[endog_i]) # no need to do this in STAN

	m = 1
	for (j in (N_endog_expand - expansion + 1):N_endog_expand) {
		# j goes from first to last element position of previous expansion
		for (k in l_starts[endog_i]:l_ends[endog_i]) {
			# k goes from first to last element position for endog variable i in lambdas_base
			lambdas_temp[m] = lambdas[j] * lambdas_base[k]
			m = m + 1
		}
	}

	expansion = expansion * N_endog_each[endog_i]
	endog_i = endog_i - 1
	lambdas[(N_endog_expand - expansion + 1):N_endog_expand] = lambdas_temp
}

# PIS STUFF

pis_base <- apply(beta_prior, MARGIN = 1, FUN = function(pr) rbeta(1, pr[1], pr[2])) # to simplify things
pis = matrix(1, nrow = N_data, ncol = N_endog_expand)

for (i in 1:K_exog) {

	pis_temp <- rep(NA, N_endog_expand)
	pis_temp_each <- rep(NA, N_exog_each[i]*p_each[i])

	pos = 1
	for (j in 1:N_exog_each[i]) {
		pis_temp_each[pos:(pos + p_each[i] - 1)] = rep(pis_base[j], p_each[i]);
		pos = pos + p_each[i];
	}

	pis_temp[1:(N_exog_each[i]*p_each[i])] = pis_temp_each

	counter = p_times[i]
	while (counter > 1) {
		pis_temp = c(pis_temp,pis_temp_each)
		counter = counter - 1
	}

	pis = pis * (max_possible_data[,i] %*% t(pis_temp) +
								(1 - max_possible_data[,i]) %*% t(1 - pis_temp))

}

# MAGIC STUFF

w <- lambdas %*% t(A * pis)

# check
stopifnot(
	all.equal(target = 1, current =  sum(w))
)

w_full <- A_w %*% t(w)

# check
for (i in 1:K_strategies) {
	stopifnot(
		all.equal(target = 1,
							current =  sum(w_full[w_starts[i]:w_ends[i]]))
	)
}

# Y STUFF
Ys <- c()
for (i in 1:K_strategies) {
	Ys <- c(Ys, as.vector(rmultinom(n = 1, size = 25, w_full[w_starts[i]:w_ends[i]])))
}



# RUN GBIQQ ------------------------------------------------------------------------------------

biqq_data <-
	list(K = K,
			 K_endog = K_endog,
			 K_exog = K_exog,
			 N_endog_each = N_endog_each,
			 N_types = N_types,
			 N_events = N_events,
			 N_data = N_data,
			 N_endog_expand = N_endog_expand,
			 max_possible_data = max_possible_data,
			 dirichlet_prior = dirichlet_prior,
			 l_starts = l_starts,
			 l_ends = l_ends,
			 N_exog_each = as.array(N_exog_each),
			 N_exog_types = N_exog_types,
			 beta_prior = beta_prior,
			 p_starts = as.array(p_starts),
			 p_ends = as.array(p_ends),
			 p_times = as.array(p_times),
			 p_each = as.array(p_each),
			 K_strategies = K_strategies,
			 w_starts = w_starts,
			 w_ends = w_ends,
			 A_w = A_w,
			 A = A,
			 Y = Y #,
			 #lambdas_base = lambdas_base
			 )

initf <- function() {
	list(gamma = array(rep(1, times = (N_types - K_endog))),
			 pis_base = array(rep(.5, times = N_exog_types)))
}

n_chains <- 4
setwd("../")
test <- rstan::stan(file = "other/gbiqq_ragged_simplex.stan",
										data = biqq_data,
										init = initf,
										# algorithm = "Fixed_param",
										iter = 2000,
										warmup = 1000,
										chains = 1,
										pars = c("lambdas_base", "pis_base"),
										cores = parallel::detectCores(),
										control = list(adapt_delta = .999,
																	 max_treedepth = 15)
										)

print(test)

# REPORT --------------------------------------------------------------------------------------

pairs_exam <- 2

rstan:::pairs.stanfit(test,
											pars = c(paste0("lambdas_base[",l_starts[pairs_exam]:l_ends[pairs_exam],"]")),
											include = TRUE)

t <- rstan::As.mcmc.list(test)


# report lambdas
lapply(1:K_endog,
			 FUN = function(endog) {

			 	t_temp <- t[[1]][,l_starts[endog]:l_ends[endog]]

			 	for (i in 2:n_chains) {
			 		t_temp <- t_temp + t[[i]][,l_starts[endog]:l_ends[endog]]
			 	}

			 	as_data_frame(t(apply(t_temp/n_chains, 2,
			 				FUN = function(x) {
			 					x <- c(mn = mean(x), sd = sd(x), fivenum(x))
			 					names(x) <- c("mn", "sd", "min", "l_hinge", "med", "u_hinge", "max")
			 					return(x)
			 				})))

			 }) %>%
	`names<-`(gbiqq::get_endogenous_vars(democratization_dag))

```

