#' Make compact data with data strategies
#'
#' Take a `data.frame` and return compact `data.frame`` of event types and strategies.
#'
#' @param data A data.frame of variables that can take three values: 0, 1, and NA
#' @param model A model object generated by \code{make_model()}.
#' @param removeNA Logical. Whether to exclude strategy families that contain no observed data. Eceptionally if no data is provided, minimal data on data on first node is returned.
#' @param remove_family Logical. If `FALSE`, removes column \code{strategy} from the output.
#' @param summary Logical. Whether to return summary of the data. See details.
#' @export
#'
#' @return A vector of data events
#'
#' If \code{summary = TRUE} `collapse_data` returns a list containing the following components:
#' \item{data_events}{A compact data.frame of event types and strategies.}
#'    \item{observed_events}{A vector of character strings specifying the events observed in the data}
#'    \item{unobserved_events}{A vector of character strings specifying the events not observed in the data}
#'    \item{used_strategies}{A vector of character strings specifying the strategies with observed data}
#'    \item{unused_strategies}{A vector of character strings specifying the strategies containing no observed data}
#' @examples
#'
#' model <- make_model("X -> Y")
#' df <- simulate_data(model, n = 10)
#' df[1,1] <- ""
#' collapse_data(df, model)
#'
#' collapse_data(df, model, removeNA = FALSE)
#'
#' collapse_data(df, model, remove_family = TRUE)
#'
#' collapse_data(df, model, summary = TRUE)
#'
#' data <- simulate_data(model, n = 0)
#' collapse_data(data, model)
#'
collapse_data <- function(data, model, removeNA = TRUE, remove_family = FALSE, summary = FALSE){

	if(nrow(data) ==0 | all(is.na(data))) {
		data_events <- gbiqq:::minimal_event_data(model)
		removeNA <- FALSE

	} else {

	likelihood_helpers  <- get_likelihood_helpers(model)
	possible_events     <- likelihood_helpers$possible_events
	possible_strategies <- names(likelihood_helpers$w_starts)
	variables           <- model$variables
	i_strategy          <- likelihood_helpers$w_ends - likelihood_helpers$w_starts +1


	if(!all(variables %in% names(data))){stop("Could not find all of the variables in the DAG in
																						the data you provided.\nPlease double-check variable
																						names and try again.")}

	revealed_data <- reveal_outcomes(model)
	data <- data[,variables]
  data[data == ""] <- NA
	# Check if observed data is in conflict with restrictions
	inconsistencies <- !apply(data, 1, function(observed){
		any(apply(revealed_data, 1, function(possible){
			!any(possible[!is.na(observed)] != observed[!is.na(observed)])}
		))
	})

	if(any(inconsistencies)){
		message(paste("Observations are not consistent with restrictions in", sum(inconsistencies), "cases"))
		data <- data[!inconsistencies, ]
	}

	# replace "" with na and remove rows where all values are na
	data <- data[!apply(data, 1,  function(x) all(is.na(x) | x == "")),]
	data[is.na(data)] <- ""


	# Data events dataframe
	data_type <- apply(X = data, MARGIN = 1, FUN = function(row){
		paste0(variables[!(row == "")],row[!(row == "")], collapse = "")})

	data_events <- data.frame(event = possible_events,
														strategy   = rep(possible_strategies, i_strategy),
														count = 0,
														stringsAsFactors = FALSE,
														row.names = NULL)

	data_events$count <- sapply(data_events$event, function(j) sum(data_type == paste(j)))
  }

	# Output varies according to args
	if(removeNA){
		data_events <- gbiqq:::trim_strategies(data_events)
	}
	if(remove_family){
		data_events <- dplyr::select(data_events, -"strategy")
	}
	if(summary){
		return(list(
			data_events       = data_events,
			observed_events   = with(data_events, unique(event[count>0])),
			unobserved_events = with(data_events, unique(event[count==0]))
			#,
			#used_strategies   = with(data_events, unique(strategy[count>0])),
			#unused_strategies = with(data_events, unique(strategy[count==0]))
			))
	} else{
  	return(data_events)
  }

}


#' Trim strategies
#'
#' @param data_events A data.frame whose columns are \code{event}, \code{strategy} and \code{count}
#' @return Returns data events with strategies (excluding  strategy families that contain no observed data)
#'
#' @examples
#' model <- make_model("X -> Y")
#' data <- simulate_data(model, n = 10)
#' data[1,1] <- ""
#' \dontrun{trim_strategies(model, data)}
trim_strategies <- function(data_events){

	# 1. Get data and delete all rows from strategies that contain no observed data
	if(all(is.na(data_events))) return(data_events)
	data_events_split <- split(data_events, as.factor(data_events$strategy))
	data_events_w_NA <- do.call(rbind,lapply(data_events_split, function(df){
		out <- df
		if(sum(df$count) == 0){
			out[,] <- NA
		}
		out
	}))

	delete_strategies <- !apply(data_events_w_NA, 1, function(x) all(is.na(x)))
	r_names <- rownames(data_events)
	out <- data_events_w_NA[delete_strategies, ]
	rownames(out) <- 1:nrow(out)
	out
}


#' Expand compact data object to data frame
#'
#' @param data_events A compact data frame compatible with \code{model}.
#' @param model A model object generated by \code{make_model()}.
#' @export
#' @examples
#' library(dplyr)
#' model <- make_model("X->M->Y")
#' draw_data_events(model, n = 5) %>%
#'   expand_data(model)
#' draw_data_events(model, n = 0) %>%
#'   expand_data(model)
#'
expand_data <- function(data_events, model) {

	if(class(model) != "causal_model") stop("model should be a model generated with make_model")
	if(is.null(data_events)) data_events <- minimal_event_data(model)
	if("strategy" %in% names(data_events)) data_events <- dplyr::select(data_events, - strategy)
	if(!is.data.frame(data_events) & ncol(data_events !=2)) stop("data_events should be a data frame with columns `event` and `count`")

	if(sum(data_events[,2])==0)  return(minimal_data(model))  # Special case with no data

	vars <- model$variables
	df   <- merge(all_data_types(model), data_events, by.x = "event")
	xx   <- unlist(sapply(1:nrow(df), function(i) replicate(df[i,ncol(df)], df[i, vars])))
	out  <- data.frame(matrix(xx, ncol = length(vars), byrow = TRUE))
	names(out) <- vars
	out
}


#' Data type names
#'
#' Provides names to data types
#' @param model A model object generated by \code{make_model()}.
#' @param data Data in long form
#' @export
#' @examples
#' model <- make_model("X -> Y")
#' data <- simulate_data(model, n = 2)
#' data_type_names(model, data)
#'
data_type_names <- function(model, data){
	vars <- model$variables
	data <- data[vars]
	data[data==""] <- NA
	out <- apply(data, 1, function(j) paste(paste0(vars[!is.na(j)], j[!is.na(j)]), collapse = ""))
	out[out == ""] <- "None"
	out}

#' All data types
#'
#' Creates dataframe with all data types, including NA types possible from a model
#'
#' @param model A model object generated by \code{make_model()}.
#' @export
#' @examples
#' all_data_types(make_model("X -> Y"))
all_data_types <- function(model) {
	variables <- model$variables
	m <- length(model$variables)
	df <- data.frame(perm(rep(2, m))) - 1
	df[df==-1] <- NA
	names(df) <-  variables
	data.frame(cbind(event = data_type_names(model, df), df))
}

#' Creates a compact data frame for case with no data
#'
#' FLAG: In principle this might produce conflicts with node reduction
minimal_event_data <- function(model)
data.frame(event = paste0(rep(model$variables[1], 2), 0:1),
					 strategy = rep(model$variables[1],  2),
					 count = 0,
					 stringsAsFactors = FALSE,
					 row.names = NULL)

#' Creates a data frame for case with no data
#'
#' FLAG: In principle this might produce conflicts with node reduction
minimal_data <- function(model){
	vars <- model$variables
	df <- data.frame(t(rep(NA, length(vars))))
  names(df) <- vars
  df
  }
