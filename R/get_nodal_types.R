#' Get list of types for variables in a DAG
#'
#' As type labels are hard to interpret for large models, the type list includes an attribute to help interpret them. See  \code{attr(types, interpret)}
#'
#' @param model A model object generated by \code{make_model()}.
#' @param collapse Logical. If `TRUE`, shows unique nodal types for each variable. If `FALSE`, shows for each variable a matrix with nodal types as rows and parent types as columns, if applicable.
#' @importFrom rlang is_empty
#' @export
#' @return A list of parents in a DAG
#'
#' @examples
#' require("dplyr")
#' model <- make_model("X -> K -> Y")
#' get_nodal_types(model)
#'
#' model <- make_model("X -> K -> Y") %>%
#'    set_restrictions(statement = "K[X=1]>K[X=0]") %>%
#'    set_confound(list(K = "Y[K=1]>Y[K=0]"))
#' unlist(get_nodal_types(model))
#'
get_nodal_types <- function(model, collapse = TRUE) {

	nodal_types <- model$nodal_types

	# Create and interpret list of nodal types
	variables   <- model$variables
	parents     <- get_parents(model)
	types       <- lapply(lapply(parents, length), gbiqq:::type_matrix)


	types_labels <- lapply(1:length(types), function(i){
		labels <- apply(types[[i]], 1, paste, collapse = "")
		paste0(names(types)[i], labels)
	})

	names(types_labels)<- variables

	# Add row labels
	types <- lapply(variables, function(v){
		rownames(types[[v]]) <- types_labels[[v]]
		types[[v]]
	})

	names(types)  <- variables

	if(!is.null(nodal_types)){
		types <- lapply(variables, function(v){
			mat <- types[[v]]
			cn <- colnames(mat)
			nt <- nodal_types[[v]]
			mat <- mat[nt, ]
			colnames(mat) <- cn
			mat
		})
	}

	names(types)  <- variables

	if(collapse){

		types <-	lapply(1:length(types), function(i){
			var <- names(types)[i]
			mat <- as.matrix(types[[i]])
			labels <- apply(mat,1,paste,collapse = "")
			paste0(var, labels)
		})
	}

	names(types)  <- variables

	attr(types, "interpret") <- interpret_type(model)

	types

}



#' Generate type matrix
#' @param parent_n An integer. Number of parents of a given child.
#'
type_matrix <- function(parent_n){
	type_mat <- perm(rep(1, 2^parent_n))
	if(parent_n == 0){
		labels <- NULL
	} else {
		input_mat <- perm(rep(1, parent_n))
		labels <- apply(input_mat,1,paste,collapse = "")
	}
	colnames(type_mat) <- labels
	return(type_mat)
}
