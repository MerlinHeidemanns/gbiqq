
#' Lookup nodal types according to a query
#'
#' @param model A model object generated by \code{make_model()}.
#' @param query A character vector of length 1L. An expression in string format defining nodal types to interrogate \code{reveal_outcomes()}
#' @param join_by A string. The logical expression connecting expanded types, _AND_ ("&") or _OR_ ("|"). Defaults to "|".
#' @param verbose Logical. Whether to print expanded query on the consule.
#' @export
#' @importFrom stringr str_split str_detect
#' @importFrom dplyr select
#' @return A list containing the types and the evaluated expression. `manipulated_outcomes` are the nodes on the left of a [] expression
#' @examples
#' model <- make_model("X->Y")
#'
#' lookup_nodal_type(model, "(Y[X=0] > Y[X=1])")
#' lookup_nodal_type(model, "(Y[X=0] >= Y[X=1])")
#'
#' model <- make_model("X -> M -> Y; X->Y")
#' query <- "(Y[X=0] > Y[X=1])"
#' x <- lookup_nodal_type(model, query)
#'
#' query <- "(Y[X=0, M = .] > Y[X=1, M = 0])"
#' x <- lookup_nodal_type(model, query)
#'
#'
#' query <- "(Y[] == 1)"
#' x <- lookup_nodal_type(model, query)
#' x <- lookup_nodal_type(model, query, join_by = "&")
#'
#' query <- "(X == 1)"
#' x <- lookup_nodal_type(model, query)
#'
#' query <- "(M[X=1] == M[X=0])"
#' x <- lookup_nodal_type(model, query)
#'
#' # Complements
#' model <- make_model("M->Y; X->Y")
#' query <- complements("X", "M", "Y")
#' lookup_nodal_type(model, query)

lookup_nodal_type <- function(model, query, join_by = "|", verbose = FALSE){

	# Housekeeping
	# 1. remove (), split by logical symbol and trim
	# w_query contains parts of query
	w_query <- gsub("\\(|\\)", "", query)
	w_query <- str_split(w_query, "\\==|\\+|\\-|>=|<=|>|<|!=|\\&|\\|")  #
	w_query <- sapply(unlist(w_query), function(x) trimws(x))
	dos         <- TRUE

	# 2. Grab outcome nodes in query, and stop if there are more than one var in query
	# allowed: Y[X =1] == 1 & Y[X=0] ==1
	# not allowed: M[X=1] == 1 & Y[X=0] ==1
	var <- node <- st_within(query)
	if(length(var) > 1 & sum(!duplicated(var)) > 1)
		stop(paste0("Can't lookup types for nodes " , paste0(var[!duplicated(var)], collapse = ", "), " simultaneously. Please write expression as separate queries"))

	# If there are any do operations
	########################################################
	if(grepl("\\[|\\]",  query)){

		# Add any unspecified parents: e.g for model = "X->Y<-M"; query = Y[M=0] -> Y [M=0, X=.]
		q_names <-  trimws(names(w_query))
		w_query <- sapply(w_query, gbiqq:::add_dots, model = model)
	  names(w_query) <- q_names

	  .w_query <- quoted_query <- query


   ###########################################################################
   #  Generate a "quoted query" of the form "(`Y[X=0]` > `Y[X=1]`)".
	 #  This can then be evaluated on a potential outcomes dataset.
	 # Substitute expanded in w_query back into original query
	 # paste backslashes \\ and  ` ` for matching (quoted_query)

	  for (i in 1:length(w_query)) {
	  	var              <- st_within(names(w_query)[i])
	  	string_i         <- gsub(paste0("\\[|\\]|",var), "", names(w_query)[i])
	  	string_i         <- paste0(var, "\\[", string_i, "\\]" )
	  	.w_query     <- gsub(string_i, w_query[i], .w_query)
	  	quoted_query <- gsub(string_i ,paste0("`",w_query[i],"`"), quoted_query)
	  }

	 if(grepl(".", .w_query, fixed = TRUE)){
	 	.w_query      <- expand_wildcard(.w_query, join_by = join_by, verbose = verbose)
	 	 quoted_query <- expand_wildcard(quoted_query, join_by = join_by, verbose = FALSE)
	 }

	  # FLAG: Why is this repeated
	  w_query <- gsub("\\(|\\)", "",   .w_query )
	 #w_query <- str_split(w_query, "\\==|>|<|>=|\\+|\\-|<=|!=|\\&|\\|")
	  w_query <- str_split(w_query, "\\==|\\+|\\-|>=|<=|>|<|!=|\\&|\\|")
	  w_query <- sapply(unlist(w_query), function(x) trimws(x))

	} else{
		# If there are no do operations in query
		.w_query <- quoted_query <- w_query <- query
		dos <- FALSE
		nodes <- model$nodes
		node <- nodes[sapply(nodes, function(v) grepl(v, query))]
	}

	# Magic
	# The query df provide var outcomes for relevant queried conditions, rows are types, columns are conditions
  .query_df <- lapply(w_query, function(wq) gbiqq:::lookup_nodal_type_internal(model, query = wq))
  query_df  <- do.call(cbind, .query_df)
  if(dos) colnames(query_df) <- sapply(names(.query_df), trimws)

  # The query is then evaluated on this df to see which rows satisfy the query
  value <- c(eval(parse(text = quoted_query), envir = query_df))

  names(value) <- rownames(query_df)

  return_list <- list(types = value,
								  		query = query,
  										expanded_query = .w_query,
								  		evaluated_nodes = query_df,
  										node  = node[1])

  class(return_list) <- "nodal_types"
  return(return_list)
}


#' Reveal nodal types according to a query
#'@param model A model object generated by \code{make_model()}.
#'@param query A character vector of length 1L. An expression in string format defining causal types to interrogate \code{reveal_outcomes()}

lookup_nodal_type_internal <- function(model, query){

	if(!grepl("\\D", query)) return(as.numeric(query))

	# The presence of [] indicate a do operation
	if(grepl("\\[|\\]", query)){
		w_query     <- gsub(" ", "", query)
		w_query     <- unlist(strsplit(query, ""))
		bracket_starts  <- grep( "\\[", w_query)
		bracket_ends    <- grep( "\\]", w_query)
		.query     	<- w_query[(bracket_starts):bracket_ends]

		brackets        <- grepl("\\[|\\]",  .query)
		.query      <- .query[!brackets]
		.query      <-  paste0(.query, collapse = "")
		.query      <- unlist(strsplit(.query, ","))


		dos <- sapply(.query, function(q) {

			do         <- unlist(strsplit( q, ""))
			stop       <- gregexpr("=", q, perl = TRUE)[[1]][1]  - 1
			var_name   <- paste0(do[1:stop], collapse = "")
			var_name   <- gsub(" ", "", var_name)
			value      <- paste0(do[(stop +2):nchar(q)], collapse = "")
			vars       <- model$nodes
			if(!var_name %in% vars)
				stop(paste("Variable", var_name ,"is not part of the model."))
		  out        <- value
		  names(out) <- var_name
		  out
		}, USE.NAMES = FALSE)

		dos <- sapply(dos, trimws)
		# Identify nodes
		b             <- 1:bracket_starts
		var           <- paste0(w_query[b], collapse = "")
		var           <- st_within(var)
		revealed_vars <- reveal_outcomes(model, dos, node = var)[var]
	} else{
	# If no dos check whether node in query is exogenous and error if otherwise.
	 nodes    <-	model$nodes
	 wv           <- sapply(nodes, function(v) grepl(v, query))
	 if(sum(wv) > 1)
	 	stop(paste0("Can't lookup types for nodes " , paste0(nodes[!duplicated(nodes)], collapse = ", "), " simultaneously. Please write expression as separate statements"))
	 if(nodes[wv] %in% attributes(model)$endogenous_nodes)
	 	stop( "Restrictions on observational quantities not allowed. No nodal types restricted")
	 revealed_vars        <- get_nodal_types(model, collapse = FALSE)[[nodes[wv] ]]
	 names(revealed_vars) <- nodes[wv]
	}

  return(revealed_vars)

}


#' @export
print.nodal_types <- function(x, ...) {
	print(summary(x))
	invisible(x)
}


#' @export
summary.nodal_types <- function(object, ...) {
	structure(object, class = c("summary.nodal_types", "data.frame"))

}

#' @export
print.summary.nodal_types <- function(x, ...){
	output_type  <- class(x$types)
  types_labels <- names(x$types)[x$types]
  nt           <- length(types_labels)
  cat(paste("\nNodal types satisfying query's condition(s)"))

		if(x$query != x$expanded_query)
			cat(paste("\n\n query : ", x$expanded_query,  "\n\n"))
		else
			cat(paste("\n\n query : ", x$query,  "\n\n"))

		if(length(types_labels) %% 2 != 0){
			types_labels[length(types_labels) + 1] <- ""
		}
		counter <- 2
		while (counter <= length(types_labels ) ) {
			cat(paste0(" ",types_labels [(counter -1):counter], collapse = "  "))
      cat("\n")
			counter <- counter + 2
		}

		cat(paste("\n\n Number of nodal types that meet query = ",nt ))
		cat(paste("\n Total number of nodal types related to", x$node,"= ", length(x$types)))

}


#' Helper to fill in missing do operators in causal expression
#'
#' @param q a causal query
#' @param model a model
#' @examples
#' model <- make_model("X -> Y <- M")
#' gbiqq:::add_dots("Y[X=1]", model)
#' # FLAG : FORMAT NOT RIGHT
#' gbiqq:::add_dots("Y[]", model)
#'
add_dots <- function(q, model){

	# Skip numeric strings-------------------------------
	# "query = `Y[] == 1`  would be splitted as c(`Y[]`, 1)
	# and 1 doesn't need to be processed "
	if(!grepl("\\D", q)) return(q)

	var <- st_within(q)
	if(!all(var %in% model$nodes))
		stop(paste0("Outcome node "), var, " not in model")
	# Only allow specification of var's parents

	# Identify parents not specified in query and paste them as "parent = ."
	v_parents        <- get_parents(model)[[var]]
	parents_in_q     <- gbiqq:::nodes_in_statement(v_parents, q)
	not_parents      <- gbiqq:::list_non_parents(model, var)
	not_parents_q    <- gbiqq:::nodes_in_statement(not_parents, q)
	missing_parents  <- v_parents [!v_parents%in% parents_in_q]

	if(length(not_parents_q) > 0 ){
		conjugation <- ifelse(length(not_parents_q)>1, "are not parents of", "is not a parent of")
		subjects <- paste0(not_parents_q, collapse = ", ")
		stop(paste(subjects, conjugation, var))
	}

	node <- var

	# Add wildcard if needed
	if(length(v_parents) !=  length(parents_in_q))
		q <- gbiqq:::add_wildcard(node, statement = q, parents = v_parents, missing_parents)

	q

	}
