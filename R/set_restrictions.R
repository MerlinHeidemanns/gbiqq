#' Restrict a model
#'
#' Restrict a model's parameter space. This reduces the number of nodal types and in cosequence the number of unit causal types.
#'
#' Restrictions are made to nodal types, not to unit causal types. Thus for instance in a
#' model \code{X -> M -> Y}, one cannot apply a simple restriction so that \code{Y} is nondecreasing
#' in  \code{X}, however one can restrict so that \code{M} is nondecreasing in \code{X} and \code{Y} nondecreasing in \code{M}.
#' To have a restriction that \code{Y} be nondecreasing in \code{X} would otherwise require restrictions on causal types, not nodaly types,
#' which implies a form of undeclared confounding (ie that in cases in which \code{M} is decreasing in \code{X}, \code{Y} is decreasing in \code{M}).
#'
#' Since restrictions are to nodal types, all parents of a node are implicity fixed.  Thus for model \code{make_model(`X -> Y <- W`)} the request
#' \code{set_restrictions(`(Y[X=1] == 0)`)}
#' is interpreted as \code{set_restrictions(`(Y[X=1, W=0] == 0 | Y[X=1, W=1] == 0)`)}.
#'
#'
#' Statements with implicitly controlled nodes should be surrounded by parentheses, as in these examples.
#'
#'
#' Note that prior probabilities are redistributed over remaining types.
#'
#' @param model A model object generated by \code{make_model()}.
#' @param statement  A quoted expressions defining the restriction. If values for some parents are not specified, statements should be surrounded by parentheses, for instance \code{(Y[A = 1] > Y[A=0])} will be interpreted for all combinations of other parents of Y set at possible levels they might take.
#' @param join_by A string. The logical operator joining expanded types when \code{statement} contains wildcard (\code{.}). Can take values \code{"&"} (logical AND) or \code{"|"} (logical OR). When restriction contains wildcard (\code{.}) and \code{join_by} is not specified, it defaults to \code{"|"}, otherwise it defaults to \code{NULL}. Note that join_by joins within statements, not across statements.
#' @param labels A list of character vectors specifying nodal types to be kept or removed from the model. Use \code{get_nodal_types} to see syntax. Note that \code{labels} gets overwritten by \code{statement} if \code{statement} is not NULL.
#' @param keep Logical. If `FALSE`, removes and if `TRUE` keeps only causal types specified by \code{statement} or \code{labels}.
#' @param verbose Logical. Whether to print expanded \code{statement} on the console.
#'
#' @family restrictions
#'
#' @export
#' @return A restricted model with nodal types saved as attributes.
#'
#' @examples
#'
#' # 1. Restrict parameter space using statements
#' model <- make_model("X->Y") %>%
#'   set_restrictions(statement = c("X == 0"))
#'
#' model <- make_model("X -> Y <- W") %>%
#'   set_restrictions(c(decreasing("X", "Y"), substitutes("X", "W", "Y")))
#'
#' model$parameters_df
#'
#' model <- make_model("X-> Y <- W") %>%
#'   set_restrictions(statement = decreasing("X", "Y"))
#' model$parameters_df
#'
#' model <- make_model("X->Y") %>%
#'   set_restrictions(decreasing("X", "Y"))
#' model$parameters_df
#'
#' model <- make_model("X->Y") %>%
#'   set_restrictions(c(increasing("X", "Y"), decreasing("X", "Y")))
#' model$parameters_df
#'
#' # Restrict to define a model with monotonicity
#' model <- make_model("X->Y") %>%
#' set_restrictions(statement = c("Y[X=1] < Y[X=0]"))
#' get_parameter_matrix(model)
#'
#' # Restrict to a single type in endogenous node
#' model <- make_model("X->Y") %>%
#' set_restrictions(statement =  "(Y[X = 1] == 1)", join_by = "&", keep = TRUE)
#' get_parameter_matrix(model)
#'
#' # Restrict multiple nodes
#' model <- make_model("X->Y<-M; X -> M" ) %>%
#' set_restrictions(statement =  c("(Y[X = 1] == 1)", "(M[X = 1] == 1)"), join_by = "&", keep = TRUE)
#' get_parameter_matrix(model)
#'
#' # Restrictions on levels for endogenous nodes aren't allowed
#' \dontrun{
#' model <- make_model("X->Y") %>%
#' set_restrictions(statement =  "(Y == 1)")
#' }
#'
#' # 2. Restrict parameter space Using labels:
#' model <- make_model("X->Y") %>%
#' set_restrictions(labels = list(X = "X0", Y = "Y00"))
#'
#' # Restrictions can be  with wildcards
#' model <- make_model("X->Y") %>%
#' set_restrictions(labels = list(Y = "Y?0"))
#' get_parameter_matrix(model)
#'
#' # Running example: there are only four causal types
#' model <- make_model("S -> C -> Y <- R <- X; X -> C -> R") %>%
#' set_restrictions(labels = list(C = "C1000", R = "R0001", Y = "Y0001"), keep = TRUE)
#' get_parameter_matrix(model)
#'
set_restrictions <- function(model,
														 statement = NULL,
														 join_by = "|",
														 labels = NULL,
														 keep = FALSE,
														 verbose = FALSE
														 ){

  # nodal_types0 <- get_nodal_types(model)
	nodal_types0 <- model$nodal_types

	if(!is.logical(keep)) stop("`keep` should be either 'TRUE' or 'FALSE'")

	if(is.null(labels) & is.null(statement) ) {message("No restrictions provided: provide either a causal statement or nodal type labels."); return(model)}

	if(!is.null(labels) & !is.null(statement) ) {message("Provide either a causal statement or nodal type labels, not both."); return(model)}

	# Labels
	if(!is.null(labels))		model <-
			restrict_by_labels(model, labels = labels, keep = keep)

	# Statement
	if(!is.null(statement))		model <-
			gbiqq:::restrict_by_query(model, statement = statement,
																join_by = join_by, keep = keep, verbose = verbose)

	# Remove spare P matrix columns for causal types for which there are no component nodal types
	if(!is.null(model$P)){
	 remaining_causal_type_names <- rownames(update_causal_types(model))
	 model$P <- model$P[, colnames(model$P) %in% remaining_causal_type_names]
	 }


	# Keep restricted types as attributes
	nodal_types1 <- model$nodal_types
	restrictions <- sapply(model$nodes, function(node){
		restricted <- !nodal_types0[[node]] %in% nodal_types1[[node]]
		nodal_types0[[node]][restricted]
	}, simplify = FALSE, USE.NAMES = TRUE)

	restrictions <- Filter(length, restrictions)
	if(is.null(attr(model,"restrictions"))){
		attr(model,"restrictions") <- restrictions
	} else {
		restrictions0 <- attr(model,"restrictions")
		attr(model,"restrictions") <- sapply(model$nodes, function(node){
			c(restrictions[[node]], restrictions0[[node]])
		}, simplify = FALSE, USE.NAMES = TRUE)
	}

	return(model)
}


#' Reduce nodal types
#'
#' @param model a model created by make_model()
#' @param statement a list of character vectors specifying nodal types to be removed from the model. Use \code{get_nodal_types} to see syntax.
#' @param join_by A string or a list of strings. The logical operator joining expanded types when \code{statement} contains wildcard (\code{.}). Can take values \code{"&"} (logical AND) or \code{"|"} (logical OR). When restriction contains wildcard (\code{.}) and \code{join_by} is not specified, it defaults to \code{"|"}, otherwise it defaults to \code{NULL}.
#' @param keep Logical. If `FALSE`, removes and if `TRUE` keeps only causal types specified by \code{restriction}.
#' @param verbose Logical. Whether to print expanded query on the console.
#'
#' @family restrictions

restrict_by_query <- function(model,
															statement,
															join_by = "|",
															keep = FALSE,
															verbose = FALSE){

	# nodal_types    <- get_nodal_types(model)
	nodal_types    <- model$nodal_types

	n_restrictions <- length(statement)

	if(!is.logical(keep)) stop("`keep` should be either 'TRUE' or 'FALSE'")

	if(length(join_by) == 1){
			join_by <- rep(join_by, n_restrictions)
		} else if(length(join_by) != n_restrictions){
			stop(paste0("Argument `join_by` must be either of length 1 or have the same lenght as `restriction` argument."))
		}

	restrictions_list <- lapply(1:n_restrictions, function(i){
			lookup_type(model, query = statement[i], join_by = join_by[i], verbose = verbose)})

	nodes_list   <- sapply(restrictions_list, function(r) r$node)

	restrictions_list2 <- lapply(restrictions_list,  function(x) names(x$types)[x$types])

	names(restrictions_list2) <- 	nodes_list
	unique_nodes <- unique(nodes_list)

	# Run through unique nodes and get all restricted types for the node
	selected_types <- sapply(unique_nodes, function(node){
			i <- which(nodes_list == node)
			rl <- restrictions_list[i]
			unique(unlist(c(sapply(rl, function(x) names(x$types)[x$types]))))
		}, simplify = FALSE)

	# Clean up: Go through each node; figure out what to drop
	# Remove from parameters_df and P matrix
	for(node in unique_nodes){

			kept_types   <- (nodal_types[[node]] %in% selected_types[[node]])

			if(!keep){ kept_types <- !kept_types }

			if(sum(kept_types) == 0) {
						stop(paste0("nodal_types can't be entirely reduced. Revise conditions for node ", node))}

			# What to keep in nodal_types
			kept_labels <- nodal_types[[node]][kept_types] # to be used for P
			drop_labels <- nodal_types[[node]][!kept_types] # to be used for P

      # Adjust nodal_types
			nodal_types[[node]]   <- kept_labels
			model$nodal_types   <- nodal_types

			# Adjust P: What to drop
			drop_rows <- model$parameters_df$node %in% drop_labels

      # Now drop
			model$parameters_df <- model$parameters_df %>%
				filter(!drop_rows)  %>%
				gbiqq:::clean_params(warning = FALSE)

			if(!is.null(model$P)) model$P <- model$P[!drop_rows,]


	}
  model$causal_types <- update_causal_types(model)
	model
}


#' Reduce nodal types using labels
#'
#' @param model a model created by make_model()
#' @param labels A list of character vectors specifying nodal types to be kept or removed from the model.
#' @param keep Logical. If `FALSE`, removes and if `TRUE` keeps only causal types specified by \code{restriction}.
#'
#' @family restrictions

restrict_by_labels <- function(model, labels, keep = FALSE){

	nodes   <- model$nodes
	# nodal_types <- get_nodal_types(model)
	nodal_types <- model$nodal_types

	# Stop if none of the names of the labels vector matches nodes in dag
	# Stop if there's any labels name that doesn't match any of the nodes in the dag
	restricted_vars <- names(labels)
	matches    <- restricted_vars %in% nodes
	if(!any(matches)){
		stop("labels don't match nodes in DAG")
	} else if(any(!matches)){
		stop("Variables ", paste(names(labels[!matches ]) ,"are not part of the model."))
	}

	# If there are wild cards, spell them out
	labels_list <- lapply(labels, function(j) unique(unlist(sapply(j, unpack_wildcard))))

	# If "keep" specified, reverse meaning of restricted types -- only stipulated types to be kept
	if(!is.logical(keep)) stop("`keep` should be either 'TRUE' or 'FALSE'")
	if(keep) for(j in names(labels)){

		labels_list <-
			sapply(names(labels_list), function(j){
				nodal_types[[j]][!(nodal_types[[j]] %in% labels_list[[j]])]
			}, simplify = FALSE)

	}
	nodal_types_labels <- nodal_types[restricted_vars]


	# Paste vars to labels when needed
	# For flexibility, labels can be written as "0" or "X0" for an exogenous var X
	# Though, we'd write its nodal_types as "X0" or "X1"
	# length(labels) = n_vars for which labels were specified
	labels_out <- lapply(1:length(labels_list), function(i){

		#Identify nodal_types, var name and actual labels statement for the current labels
		ntr <- nodal_types_labels[[i]]
		restricted_var <- restricted_vars[i]
		labels_i <- labels_list[[i]]
		if(length(ntr) == length(labels_i)) {
			stop(paste0("nodal_types can't be entirely reduced. Revise labels for node ", restricted_var))
		}
		# Run through vector of labels for current restricted node
		labels_i <- sapply(1:length(labels_i), function(j){
			labels_ij <- labels_i[j]
			# if labels doesn't contain node's name
			# it pastes restricted var to labels
			labels_ij <- ifelse(grepl(restricted_var, labels_ij),
															 labels_ij,
															 paste0(restricted_var, labels_ij))
			#  stop if labels doesn't conform to nodal_types syntax (i.e. it doesn't look like Y00)
			#			if(!labels_ij  %in% ntr){stop(paste0("labels ",	labels_ij, " not conformable to nodal_types"))}
			# and return labelss if it does.
			labels_ij})

		## Nodal types are reduced here!
		nodal_types[[restricted_var]] <<- ntr[!ntr %in% labels_i]
		labels_i
	})

	names(labels_out)   <- restricted_vars
	model$nodal_types   <- nodal_types
	model$causal_types  <- update_causal_types(model)

	type_names          <- get_type_names(nodal_types)

	# if(!is.null(model$parameters_df$priors))
	# 	model$parameters_df$priors <- model$parameters_df$priors[type_names]
	# if(!is.null(model$parameters)) model$parameters <-
	# 	reduce_parameters(model, model$parameters)

	model$parameters_df <- dplyr::filter(model$parameters_df, param_names%in% type_names) %>%
		gbiqq:::clean_params(warning = FALSE)

	return(model)

	}


#' Get type names
#' @param nodal_types Nodal types of a model. See \code{get_nodal_types()}.
#'
get_type_names <- function(nodal_types) {
	unlist(sapply(1:length(nodal_types), function(i){
		name <- names(nodal_types)[i]
		a    <- nodal_types[[i]]
		paste(name, a, sep =".")
	}))}


#' Unpack a wild card
#' @param x A string of length 1L. A nodal type containing one or more wildcard characters "." to be unpacked.

unpack_wildcard <- function(x) {
	splitstring <- strsplit(x, "")[[1]]
	n_wild <- sum(splitstring=="?")
	if(n_wild ==0) return(x)
	variations <- perm(rep(1, n_wild))
	apply(variations, 1, function(j)  {
		z <- splitstring
		z[z=="?"] <- j
		paste0(z, collapse = "")})}

#' Update causal types based on nodal types
#' @param model A model object generated with \code{make_model}
#' @examples
#' update_causal_types(make_model("X->Y"))
#' @export
update_causal_types <- function(model){

	possible_types <-	get_nodal_types(model)
	nodes      <- model$nodes

	# Remove var name prefix from nodal types (Y00 -> 00)
	possible_types <- lapply(nodes, function(v) gsub(v, "", possible_types[[v]]))
	names(possible_types) <- nodes

	# Get types as the combination of nodal types/possible_data. for X->Y: X0Y00, X1Y00, X0Y10, X1Y10...
	df <- data.frame(expand.grid(possible_types, stringsAsFactors = FALSE))

	# Add names
	cnames       <-  causal_type_names(df)
	rownames(df) <-  do.call(paste, c(cnames, sep ="."))

	# Export
	df

}
