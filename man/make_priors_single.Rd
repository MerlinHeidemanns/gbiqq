% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/set_priors.R
\name{make_priors_single}
\alias{make_priors_single}
\title{make_priors_single}
\usage{
make_priors_single(
  model,
  distribution = NA,
  alphas = NA,
  node = NA,
  label = NA,
  statement = NA,
  confound = NA,
  nodal_type = NA,
  param_names = NA,
  param_set = NA
)
}
\arguments{
\item{model}{A model created with \code{make_model}}

\item{distribution}{String indicating a common prior distribution (uniform, jeffreys or certainty)}

\item{alphas}{Real positive numbers giving hyperparameters of the Dirichlet distribution}

\item{node}{A string indicating nodes for which priors are to be altered}

\item{label}{String. Label for nodal type indicating nodal types for which priors are to be altered}

\item{statement}{A causal query that determines nodal types for which priors are to be altered}

\item{confound}{A confound statement that restricts nodal types for which priors are to be altered}

\item{nodal_type}{String. Label for nodal type indicating nodal types for which priors are to be altered}

\item{param_names}{String. The name of specific parameter in the form of, for example, 'X.1', 'Y.01'}

\item{param_set}{String. Indicates the name of the set of parameters to be modified (useful when setting confounds)}
}
\description{
This is the one step function for make_priors, it creates the priors to be passed on nodal types with \code{set_priors}. See \code{make_priors} for more help.
}
\details{
Forbidden statements include:
\itemize{
  \item Setting \code{distribution} and \code{alphas} at the same time.
  \item Setting a \code{distribution} other than uniform, jeffreys or certainty.
  \item Setting negative priors.
}
}
\examples{
model <- make_model('X -> M -> Y; X->Y')

gbiqq:::make_priors_single(model, distribution = 'jeffreys')

gbiqq:::make_priors_single(model, alphas = 3)

# Examples of selecting subsets
# By node
gbiqq:::make_priors_single(model, node = 'M', alphas = 8)

# By nodal type statement
gbiqq:::make_priors_single(model,
        statement = '(Y[X=1, M = .] > Y[X=0, M = .])', alphas = 2)

# By nodal type label (safest to provide node also)
gbiqq:::make_priors_single(model, node = 'X', label = '0', alphas = 9)

# By confound query: Applies only to types that are involved in confounding
# Only alters named node in confound, even if other nodes are listed in 'nodes'
confounds <- list(X = 'Y[X=1] > Y[X=0]', X = 'Y[X=1] < Y[X=0]')
model     <- make_model('X->Y') \%>\% set_confound(confounds)
gbiqq:::make_priors_single(model, confound = confounds[1], alphas = 3)
gbiqq:::make_priors_single(model, node = 'Y', confound = confounds[1], alphas = 3)

# A residual  confound condition can also be defined
gbiqq:::make_priors_single(model, confound = list(X = '!(Y[X=1] > Y[X=0])'), alphas = 3)
gbiqq:::make_priors_single(model, confound = list(X = '(Y[X=1] == Y[X=0])'), alphas = 3)

# make_priors_single can also be used for some vector valued statements
model <- make_model('X -> M -> Y')
gbiqq:::make_priors_single(model, node = c('X', 'Y'), alphas = 2)
gbiqq:::make_priors_single(model, label = c('1', '01'), alphas = 2)

# Incompatible conditions produce no change
# Such cases best handled by  make_priors
gbiqq:::make_priors_single(model, node = 'X', label = '01', alphas = 2)

# Problematic example
\dontrun{
gbiqq:::make_priors_single(model, alphas = 1:2)
}

}
\seealso{
Other priors: 
\code{\link{get_priors}()},
\code{\link{make_priors}()},
\code{\link{set_priors}()}
}
\concept{priors}
