
R version 3.6.2 (2019-12-12) -- "Dark and Stormy Night"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "gbiqq"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> library('gbiqq')
Loading required package: dplyr

Attaching package: 'dplyr'

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union

Loading required package: Rcpp
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("add_dots")
> ### * add_dots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_dots
> ### Title: Helper to fill in missing do operators in causal expression
> ### Aliases: add_dots
> 
> ### ** Examples
> 
> model <- make_model('X -> Y <- M')
> gbiqq:::add_dots('Y[X=1]', model)
[1] "Y[X=1, M= .]"
> gbiqq:::add_dots('Y[]', model)
[1] "Y[M= ., X= .]"
> 
> 
> 
> 
> cleanEx()
> nameEx("all_data_types")
> ### * all_data_types
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all_data_types
> ### Title: All data types
> ### Aliases: all_data_types
> 
> ### ** Examples
> 
> all_data_types(make_model('X -> Y'))
     event  X  Y
X0Y0  X0Y0  0  0
X1Y0  X1Y0  1  0
X0Y1  X0Y1  0  1
X1Y1  X1Y1  1  1
Y0      Y0 NA  0
Y1      Y1 NA  1
X0      X0  0 NA
X1      X1  1 NA
None  None NA NA
> model <- make_model('X -> Y') %>% set_restrictions(labels = list(Y = '00'), keep = TRUE)
>   all_data_types(model)
     event  X  Y
X0Y0  X0Y0  0  0
X1Y0  X1Y0  1  0
X0Y1  X0Y1  0  1
X1Y1  X1Y1  1  1
Y0      Y0 NA  0
Y1      Y1 NA  1
X0      X0  0 NA
X1      X1  1 NA
None  None NA NA
>   all_data_types(model, complete_data = TRUE)
     event X Y
X0Y0  X0Y0 0 0
X1Y0  X1Y0 1 0
X0Y1  X0Y1 0 1
X1Y1  X1Y1 1 1
>   all_data_types(model, possible_data = TRUE)
     event X Y
X0Y0  X0Y0 0 0
X1Y0  X1Y0 1 0
>   all_data_types(model, given  = 'X==1')
     event X  Y
X1Y0  X1Y0 1  0
X1Y1  X1Y1 1  1
X1      X1 1 NA
>   all_data_types(model, given  = 'X==1 & Y==1')
     event X Y
X1Y1  X1Y1 1 1
> 
> 
> 
> 
> cleanEx()
> nameEx("clean_params")
> ### * clean_params
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clean_params
> ### Title: Check parameters sum to 1 in paramset; normalize if needed; add
> ###   names if needed
> ### Aliases: clean_params
> 
> ### ** Examples
> 
> model <- make_model('X->Y')
> model$parameters_df$param_value <- 1:6
> clean_params(model$parameters_df, warning = TRUE)
Parameters in set X do not sum to 1. Using normalized parameters
Parameters in set Y do not sum to 1. Using normalized parameters
  param_names param_value param_set node nodal_type gen priors
1         X.0   0.3333333         X    X          0   1      1
2         X.1   0.6666667         X    X          1   1      1
3        Y.00   0.1666667         Y    Y         00   2      1
4        Y.10   0.2222222         Y    Y         10   2      1
5        Y.01   0.2777778         Y    Y         01   2      1
6        Y.11   0.3333333         Y    Y         11   2      1
> 
> 
> 
> cleanEx()
> nameEx("collapse_data")
> ### * collapse_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: collapse_data
> ### Title: Make compact data with data strategies
> ### Aliases: collapse_data
> 
> ### ** Examples
> 
> 
> model <- make_model('X -> Y')
> df <- simulate_data(model, n = 10)
> df[1,1] <- ''
> collapse_data(df, model)
  event strategy count
1  X0Y0       XY     1
2  X1Y0       XY     2
3  X0Y1       XY     3
4  X1Y1       XY     3
5    Y0        Y     1
6    Y1        Y     0
> 
> collapse_data(df, model, drop_NA = FALSE)
  event strategy count
1  X0Y0       XY     1
2  X1Y0       XY     2
3  X0Y1       XY     3
4  X1Y1       XY     3
5    Y0        Y     1
6    Y1        Y     0
7    X0        X     0
8    X1        X     0
> 
> collapse_data(df, model, drop_family = TRUE)
  event count
1  X0Y0     1
2  X1Y0     2
3  X0Y1     3
4  X1Y1     3
5    Y0     1
6    Y1     0
> 
> collapse_data(df, model, summary = TRUE)
$data_events
  event strategy count
1  X0Y0       XY     1
2  X1Y0       XY     2
3  X0Y1       XY     3
4  X1Y1       XY     3
5    Y0        Y     1
6    Y1        Y     0

$observed_events
[1] "X0Y0" "X1Y0" "X0Y1" "X1Y1" "Y0"  

$unobserved_events
[1] "Y1"

> 
> data <- simulate_data(model, n = 0)
> collapse_data(data, model)
  event strategy count
1  X0Y0       XY     0
2  X1Y0       XY     0
3  X0Y1       XY     0
4  X1Y1       XY     0
> 
> model <- make_model('X -> Y') %>% set_restrictions('X==1')
> df <- simulate_data(model, n = 10)
> df[1,1] <- ''
> collapse_data(df, model)
  event strategy count
1  X0Y0       XY     3
2  X0Y1       XY     6
3    Y0        Y     1
4    Y1        Y     0
> data <- data.frame(X= 0:1)
> collapse_data(data, model)
X1 data is inconsistent with model and ignored
  event strategy count
1    X0        X     1
> 
> model <- make_model('X->Y')
> long_data <- simulate_data(model, n = 6)
> collapse_data(long_data, model)
  event strategy count
1  X0Y0       XY     3
2  X1Y0       XY     2
3  X0Y1       XY     1
4  X1Y1       XY     0
> 
> 
> 
> cleanEx()
> nameEx("complements")
> ### * complements
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: complements
> ### Title: Make statement for complements
> ### Aliases: complements
> 
> ### ** Examples
> 
> complements('A', 'B', 'W')
[1] "((W[A =1, B = 1]) - (W[A = 0, B = 1])) > ((W[A =1, B = 0]) - (W[A = 0, B = 0]))"
attr(,"class")
[1] "statement"
> 
> 
> 
> 
> cleanEx()
> nameEx("continue_names")
> ### * continue_names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: continue_names
> ### Title: Continue names
> ### Aliases: continue_names
> 
> ### ** Examples
> 
> x <- c('S_3', 'S_3', 'S_5')
> gbiqq:::continue_names(x)
[1] "S_9"  "S_9"  "S_11"
> 
> 
> 
> cleanEx()
> nameEx("data_type_names")
> ### * data_type_names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data_type_names
> ### Title: Data type names
> ### Aliases: data_type_names
> 
> ### ** Examples
> 
> model <- make_model('X -> Y')
> data <- simulate_data(model, n = 2)
> data_type_names(model, data)
[1] "X0Y1" "X1Y1"
> 
> 
> 
> 
> cleanEx()
> nameEx("decreasing")
> ### * decreasing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: decreasing
> ### Title: Make monotonicity statement (negative)
> ### Aliases: decreasing
> 
> ### ** Examples
> 
> decreasing('A', 'B')
[1] "(B[A=1] < B[A=0])"
attr(,"class")
[1] "statement"
> 
> 
> 
> 
> cleanEx()
> nameEx("drop_empty_families")
> ### * drop_empty_families
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drop_empty_families
> ### Title: Drop empty families
> ### Aliases: drop_empty_families
> 
> ### ** Examples
> 
> 
> data_events <- data.frame(event = c('X0Y0', 'Y0'), strategy = c('XY', 'Y'), count = 1:0)
> gbiqq:::drop_empty_families(data_events)
  event strategy count
1  X0Y0       XY     1
> 
> 
> 
> 
> cleanEx()
> nameEx("expand_data")
> ### * expand_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand_data
> ### Title: Expand compact data object to data frame
> ### Aliases: expand_data
> 
> ### ** Examples
> 
> model <- make_model('X->M->Y')
> simulate_events(model, n = 5) %>%
+   expand_data(model)
  X M Y
1 0 1 0
2 1 0 1
3 1 0 1
4 1 1 0
5 1 1 0
> simulate_events(model, n = 0) %>%
+   expand_data(model)
   X  M  Y
1 NA NA NA
> 
> 
> 
> 
> cleanEx()
> nameEx("expand_wildcard")
> ### * expand_wildcard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand_wildcard
> ### Title: Expand wildcard
> ### Aliases: expand_wildcard
> 
> ### ** Examples
> 
> expand_wildcard('(Y[X=1, M=.] > Y[X=1, M=.])')
Generated expanded expression:
(Y[X=1, M=0] > Y[X=1, M=0] | Y[X=1, M=1] > Y[X=1, M=1])
[1] "(Y[X=1, M=0] > Y[X=1, M=0] | Y[X=1, M=1] > Y[X=1, M=1])"
> 
> 
> 
> 
> cleanEx()
> nameEx("get_ambiguities_matrix")
> ### * get_ambiguities_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_ambiguities_matrix
> ### Title: Get ambiguities matrix
> ### Aliases: get_ambiguities_matrix
> 
> ### ** Examples
> 
> model <- make_model('X -> Y')
> get_ambiguities_matrix(model = model)
      X0Y0 X1Y0 X0Y1 X1Y1
X0Y00    1    0    0    0
X1Y00    0    1    0    0
X0Y10    0    0    1    0
X1Y10    0    1    0    0
X0Y01    1    0    0    0
X1Y01    0    0    0    1
X0Y11    0    0    1    0
X1Y11    0    0    0    1
> 
> 
> 
> 
> cleanEx()
> nameEx("get_data_families")
> ### * get_data_families
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_data_families
> ### Title: get_data_families
> ### Aliases: get_data_families
> 
> ### ** Examples
> 
> get_data_families(model = make_model('X->Y'))
     event strategy X0Y0 X1Y0 X0Y1 X1Y1
X0Y0  X0Y0       XY    1    0    0    0
X1Y0  X1Y0       XY    0    1    0    0
X0Y1  X0Y1       XY    0    0    1    0
X1Y1  X1Y1       XY    0    0    0    1
Y0      Y0        Y    1    1    0    0
Y1      Y1        Y    0    0    1    1
X0      X0        X    1    0    1    0
X1      X1        X    0    1    0    1
> get_data_families(model = make_model('X->Y'), mapping_only = TRUE)
     X0Y0 X1Y0 X0Y1 X1Y1
X0Y0    1    0    0    0
X1Y0    0    1    0    0
X0Y1    0    0    1    0
X1Y1    0    0    0    1
Y0      1    1    0    0
Y1      0    0    1    1
X0      1    0    1    0
X1      0    1    0    1
> get_data_families(model = make_model('X-> M -> Y'))
        event strategy X0M0Y0 X1M0Y0 X0M1Y0 X1M1Y0 X0M0Y1 X1M0Y1 X0M1Y1 X1M1Y1
X0M0Y0 X0M0Y0      XMY      1      0      0      0      0      0      0      0
X1M0Y0 X1M0Y0      XMY      0      1      0      0      0      0      0      0
X0M1Y0 X0M1Y0      XMY      0      0      1      0      0      0      0      0
X1M1Y0 X1M1Y0      XMY      0      0      0      1      0      0      0      0
X0M0Y1 X0M0Y1      XMY      0      0      0      0      1      0      0      0
X1M0Y1 X1M0Y1      XMY      0      0      0      0      0      1      0      0
X0M1Y1 X0M1Y1      XMY      0      0      0      0      0      0      1      0
X1M1Y1 X1M1Y1      XMY      0      0      0      0      0      0      0      1
M0Y0     M0Y0       MY      1      1      0      0      0      0      0      0
M1Y0     M1Y0       MY      0      0      1      1      0      0      0      0
M0Y1     M0Y1       MY      0      0      0      0      1      1      0      0
M1Y1     M1Y1       MY      0      0      0      0      0      0      1      1
X0Y0     X0Y0       XY      1      0      1      0      0      0      0      0
X1Y0     X1Y0       XY      0      1      0      1      0      0      0      0
X0Y1     X0Y1       XY      0      0      0      0      1      0      1      0
X1Y1     X1Y1       XY      0      0      0      0      0      1      0      1
X0M0     X0M0       XM      1      0      0      0      1      0      0      0
X1M0     X1M0       XM      0      1      0      0      0      1      0      0
X0M1     X0M1       XM      0      0      1      0      0      0      1      0
X1M1     X1M1       XM      0      0      0      1      0      0      0      1
Y0         Y0        Y      1      1      1      1      0      0      0      0
Y1         Y1        Y      0      0      0      0      1      1      1      1
M0         M0        M      1      1      0      0      1      1      0      0
M1         M1        M      0      0      1      1      0      0      1      1
X0         X0        X      1      0      1      0      1      0      1      0
X1         X1        X      0      1      0      1      0      1      0      1
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("get_event_prob")
> ### * get_event_prob
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_event_prob
> ### Title: Draw event probabilities
> ### Aliases: get_event_prob
> 
> ### ** Examples
> 
> model <- make_model('X -> Y')
> get_event_prob(model = model)
     event_prob
X0Y0       0.25
X1Y0       0.25
X0Y1       0.25
X1Y1       0.25
> get_event_prob(model = model, parameters = rep(1, 6))
     event_prob
X0Y0       0.25
X1Y0       0.25
X0Y1       0.25
X1Y1       0.25
> get_event_prob(model = model, parameters = 1:6)
     event_prob
X0Y0  0.1481481
X1Y0  0.2592593
X0Y1  0.1851852
X1Y1  0.4074074
> 
> 
> 
> cleanEx()
> nameEx("get_nodal_types")
> ### * get_nodal_types
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_nodal_types
> ### Title: Get list of types for nodes in a DAG
> ### Aliases: get_nodal_types
> 
> ### ** Examples
> 
> model <- make_model('X -> K -> Y')
> get_nodal_types(model)
$X
[1] "0" "1"

$K
[1] "00" "10" "01" "11"

$Y
[1] "00" "10" "01" "11"

attr(,"interpret")
attr(,"interpret")$X
  node position display interpretation
1    X       NA      X0          X = 0
2    X       NA      X1          X = 1

attr(,"interpret")$K
  node position display interpretation
1    K        1   K[*]*      K | X = 0
2    K        2   K*[*]      K | X = 1

attr(,"interpret")$Y
  node position display interpretation
1    Y        1   Y[*]*      Y | K = 0
2    Y        2   Y*[*]      Y | K = 1

> 
> model <- make_model('X -> K -> Y') %>%
+    set_restrictions(statement = 'K[X=1]>K[X=0]') %>%
+    set_confound(list(K = 'Y[K=1]>Y[K=0]'))
> unlist(get_nodal_types(model))
  X1   X2   K1   K2   K3   Y1   Y2   Y3   Y4 
 "0"  "1" "00" "10" "11" "00" "10" "01" "11" 
> 
> 
> 
> 
> cleanEx()
> nameEx("get_param_dist")
> ### * get_param_dist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_param_dist
> ### Title: Get a distribution of model parameters
> ### Aliases: get_param_dist
> 
> ### ** Examples
> 
> get_param_dist(model = make_model('X->Y'), using = 'priors', n_draws = 4)
Prior distribution added to model
            X.0       X.1       Y.00      Y.10      Y.01      Y.11
[1,] 0.07614139 0.9238586 0.09174224 0.1524219 0.3013555 0.4544803
[2,] 0.68334882 0.3166512 0.01849888 0.3388769 0.2734608 0.3691633
[3,] 0.51347987 0.4865201 0.26624696 0.1223325 0.2664709 0.3449496
[4,] 0.76308393 0.2369161 0.11603825 0.1943673 0.3080895 0.3815049
> get_param_dist(model = make_model('X->Y'), using = 'parameters')
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
0.50 0.50 0.25 0.25 0.25 0.25 
> 
> 
> 
> cleanEx()
> nameEx("get_parameter_names")
> ### * get_parameter_names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_parameter_names
> ### Title: Get parameter names
> ### Aliases: get_parameter_names
> 
> ### ** Examples
> 
> 
> get_parameter_names(make_model('X->Y'))
[1] "X.0"  "X.1"  "Y.00" "Y.10" "Y.01" "Y.11"
> 
> 
> 
> 
> cleanEx()
> nameEx("get_parameters")
> ### * get_parameters
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_parameters
> ### Title: Get parameters
> ### Aliases: get_parameters
> 
> ### ** Examples
> 
> get_parameters(make_model('X -> Y'))
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
0.50 0.50 0.25 0.25 0.25 0.25 
> 
> 
> 
> cleanEx()
> nameEx("get_parents")
> ### * get_parents
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_parents
> ### Title: Get list of parents in a dag
> ### Aliases: get_parents
> 
> ### ** Examples
> 
> model <- make_model('X -> K -> Y')
> get_parents(model)
$X
character(0)

$K
[1] "X"

$Y
[1] "K"

> 
> 
> 
> cleanEx()
> nameEx("get_prior_distribution")
> ### * get_prior_distribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_prior_distribution
> ### Title: Get a prior distribution from priors
> ### Aliases: get_prior_distribution
> 
> ### ** Examples
> 
> make_model('X -> Y') %>% set_prior_distribution(n_draws = 5) %>% get_prior_distribution()
            X.0       X.1      Y.00      Y.10       Y.01       Y.11
[1,] 0.07614139 0.9238586 0.1482124 0.2235221 0.03252097 0.59574449
[2,] 0.68334882 0.3166512 0.2441481 0.3295921 0.29206482 0.13419502
[3,] 0.51347987 0.4865201 0.3869452 0.5009050 0.04192469 0.07022503
[4,] 0.76308393 0.2369161 0.1967135 0.2435888 0.08283228 0.47686546
[5,] 0.37574002 0.6242600 0.0713293 0.4650213 0.34876419 0.11488525
> make_model('X -> Y') %>% get_prior_distribution(3)
The model does not have an attached prior distribution; generated on the fly
           X.0       X.1       Y.00      Y.10      Y.01       Y.11
[1,] 0.1922238 0.8077762 0.01814388 0.3840363 0.5458906 0.05192922
[2,] 0.0337715 0.9662285 0.28578999 0.3353391 0.2990230 0.07984787
[3,] 0.8361753 0.1638247 0.36999961 0.4786783 0.1328678 0.01845432
> 
> 
> 
> 
> cleanEx()
> nameEx("get_priors")
> ### * get_priors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_priors
> ### Title: Get priors
> ### Aliases: get_priors
> 
> ### ** Examples
> 
> get_priors(make_model('X -> Y'))
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
   1    1    1    1    1    1 
> 
> 
> 
> cleanEx()
> nameEx("get_query_types")
> ### * get_query_types
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_query_types
> ### Title: Get values of types according to a query
> ### Aliases: get_query_types
> 
> ### ** Examples
> 
> model <- make_model('X -> M -> Y; X->Y')
> query <- '(Y[X=1] > Y[X=0]) & (M[X=0]==1)'
> x <- get_query_types(model, query)
> summary(x)

Causal types satisfying query's condition(s)  

 query =  (Y[X=1] > Y[X=0]) & (M[X=0]==1) 

X0.M10.Y0100  X1.M10.Y0100
X0.M10.Y1100  X1.M10.Y1100
X0.M11.Y0001  X1.M11.Y0001
X0.M11.Y1001  X1.M11.Y1001
X0.M10.Y0101  X1.M10.Y0101
X0.M11.Y0101  X1.M11.Y0101
X0.M10.Y1101  X1.M10.Y1101
X0.M11.Y1101  X1.M11.Y1101


 Number of causal types that meet condition(s) =  16
 Total number of causal types in model =  128> 
> query <- 'Y[M=M[X=0], X=1]==1'
> x <- get_query_types(model, query)
> get_query_types(model, query)

Causal types satisfying query's condition(s)  

 query =  Y[M=M[X=0], X=1]==1 

X0.M00.Y0100  X1.M00.Y0100
X0.M01.Y0100  X1.M01.Y0100
X0.M00.Y1100  X1.M00.Y1100
X0.M01.Y1100  X1.M01.Y1100
X0.M00.Y0110  X1.M00.Y0110
X0.M01.Y0110  X1.M01.Y0110
X0.M00.Y1110  X1.M00.Y1110
X0.M01.Y1110  X1.M01.Y1110
X0.M10.Y0001  X1.M10.Y0001
X0.M11.Y0001  X1.M11.Y0001
X0.M10.Y1001  X1.M10.Y1001
X0.M11.Y1001  X1.M11.Y1001
X0.M00.Y0101  X1.M00.Y0101
X0.M10.Y0101  X1.M10.Y0101
X0.M01.Y0101  X1.M01.Y0101
X0.M11.Y0101  X1.M11.Y0101
X0.M00.Y1101  X1.M00.Y1101
X0.M10.Y1101  X1.M10.Y1101
X0.M01.Y1101  X1.M01.Y1101
X0.M11.Y1101  X1.M11.Y1101
X0.M10.Y0011  X1.M10.Y0011
X0.M11.Y0011  X1.M11.Y0011
X0.M10.Y1011  X1.M10.Y1011
X0.M11.Y1011  X1.M11.Y1011
X0.M00.Y0111  X1.M00.Y0111
X0.M10.Y0111  X1.M10.Y0111
X0.M01.Y0111  X1.M01.Y0111
X0.M11.Y0111  X1.M11.Y0111
X0.M00.Y1111  X1.M00.Y1111
X0.M10.Y1111  X1.M10.Y1111
X0.M01.Y1111  X1.M01.Y1111
X0.M11.Y1111  X1.M11.Y1111


 Number of causal types that meet condition(s) =  64
 Total number of causal types in model =  128> 
> query <- '(Y[X=1, M = 1] >  Y[X=0, M = 1]) & (Y[X=1, M = 0] >  Y[X=0, M = 0])'
> get_query_types(model, query)

Causal types satisfying query's condition(s)  

 query =  (Y[X=1, M = 1] >  Y[X=0, M = 1]) & (Y[X=1, M = 0] >  Y[X=0, M = 0]) 

X0.M00.Y0101  X1.M00.Y0101
X0.M10.Y0101  X1.M10.Y0101
X0.M01.Y0101  X1.M01.Y0101
X0.M11.Y0101  X1.M11.Y0101


 Number of causal types that meet condition(s) =  8
 Total number of causal types in model =  128> 
> query <- 'Y[X=1] == Y[X=0]'
> get_query_types(model, query)

Causal types satisfying query's condition(s)  

 query =  Y[X=1] == Y[X=0] 

X0.M00.Y0000  X1.M00.Y0000
X0.M10.Y0000  X1.M10.Y0000
X0.M01.Y0000  X1.M01.Y0000
X0.M11.Y0000  X1.M11.Y0000
X0.M10.Y1000  X1.M10.Y1000
X0.M11.Y1000  X1.M11.Y1000
X0.M01.Y0100  X1.M01.Y0100
X0.M11.Y0100  X1.M11.Y0100
X0.M00.Y1100  X1.M00.Y1100
X0.M11.Y1100  X1.M11.Y1100
X0.M00.Y0010  X1.M00.Y0010
X0.M01.Y0010  X1.M01.Y0010
X0.M10.Y0110  X1.M10.Y0110
X0.M01.Y0110  X1.M01.Y0110
X0.M00.Y1110  X1.M00.Y1110
X0.M10.Y1110  X1.M10.Y1110
X0.M00.Y0001  X1.M00.Y0001
X0.M10.Y0001  X1.M10.Y0001
X0.M10.Y1001  X1.M10.Y1001
X0.M01.Y1001  X1.M01.Y1001
X0.M00.Y1101  X1.M00.Y1101
X0.M01.Y1101  X1.M01.Y1101
X0.M00.Y0011  X1.M00.Y0011
X0.M11.Y0011  X1.M11.Y0011
X0.M01.Y1011  X1.M01.Y1011
X0.M11.Y1011  X1.M11.Y1011
X0.M10.Y0111  X1.M10.Y0111
X0.M11.Y0111  X1.M11.Y0111
X0.M00.Y1111  X1.M00.Y1111
X0.M10.Y1111  X1.M10.Y1111
X0.M01.Y1111  X1.M01.Y1111
X0.M11.Y1111  X1.M11.Y1111


 Number of causal types that meet condition(s) =  64
 Total number of causal types in model =  128> 
> query <- '(X == 1) & (M==1) & (Y ==1) & (Y[X=0] ==1)'
> x <- get_query_types(model, query)
> 
> query <- '(Y[X = .]==1)'
> get_query_types(model, query)
Generated expanded expression:
(Y[X=0]==1 | Y[X=1]==1)

Causal types satisfying query's condition(s)  

 query =  (Y[X=0]==1 | Y[X=1]==1) 

X0.M00.Y1000  X1.M00.Y1000
X0.M01.Y1000  X1.M01.Y1000
X0.M00.Y0100  X1.M00.Y0100
X0.M10.Y0100  X1.M10.Y0100
X0.M00.Y1100  X1.M00.Y1100
X0.M10.Y1100  X1.M10.Y1100
X0.M01.Y1100  X1.M01.Y1100
X0.M10.Y0010  X1.M10.Y0010
X0.M11.Y0010  X1.M11.Y0010
X0.M00.Y1010  X1.M00.Y1010
X0.M10.Y1010  X1.M10.Y1010
X0.M01.Y1010  X1.M01.Y1010
X0.M11.Y1010  X1.M11.Y1010
X0.M00.Y0110  X1.M00.Y0110
X0.M10.Y0110  X1.M10.Y0110
X0.M11.Y0110  X1.M11.Y0110
X0.M00.Y1110  X1.M00.Y1110
X0.M10.Y1110  X1.M10.Y1110
X0.M01.Y1110  X1.M01.Y1110
X0.M11.Y1110  X1.M11.Y1110
X0.M01.Y0001  X1.M01.Y0001
X0.M11.Y0001  X1.M11.Y0001
X0.M00.Y1001  X1.M00.Y1001
X0.M01.Y1001  X1.M01.Y1001
X0.M11.Y1001  X1.M11.Y1001
X0.M00.Y0101  X1.M00.Y0101
X0.M10.Y0101  X1.M10.Y0101
X0.M01.Y0101  X1.M01.Y0101
X0.M11.Y0101  X1.M11.Y0101
X0.M00.Y1101  X1.M00.Y1101
X0.M10.Y1101  X1.M10.Y1101
X0.M01.Y1101  X1.M01.Y1101
X0.M11.Y1101  X1.M11.Y1101
X0.M10.Y0011  X1.M10.Y0011
X0.M01.Y0011  X1.M01.Y0011
X0.M11.Y0011  X1.M11.Y0011
X0.M00.Y1011  X1.M00.Y1011
X0.M10.Y1011  X1.M10.Y1011
X0.M01.Y1011  X1.M01.Y1011
X0.M11.Y1011  X1.M11.Y1011
X0.M00.Y0111  X1.M00.Y0111
X0.M10.Y0111  X1.M10.Y0111
X0.M01.Y0111  X1.M01.Y0111
X0.M11.Y0111  X1.M11.Y0111
X0.M00.Y1111  X1.M00.Y1111
X0.M10.Y1111  X1.M10.Y1111
X0.M01.Y1111  X1.M01.Y1111
X0.M11.Y1111  X1.M11.Y1111


 Number of causal types that meet condition(s) =  96
 Total number of causal types in model =  128> 
> model <- make_model('X -> Y')
> 
> 
> 
> cleanEx()
> nameEx("get_type_prob")
> ### * get_type_prob
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_type_prob
> ### Title: Get type probabilities
> ### Aliases: get_type_prob
> 
> ### ** Examples
> 
> get_type_prob(model = make_model('X->Y'))
X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11 
 0.125  0.125  0.125  0.125  0.125  0.125  0.125  0.125 
> get_type_prob(model = make_model('X->Y'), parameters = 1:6)
    X0.Y00     X1.Y00     X0.Y10     X1.Y10     X0.Y01     X1.Y01     X0.Y11 
0.05555556 0.11111111 0.07407407 0.14814815 0.09259259 0.18518519 0.11111111 
    X1.Y11 
0.22222222 
> 
> 
> 
> 
> cleanEx()
> nameEx("get_type_prob_multiple")
> ### * get_type_prob_multiple
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_type_prob_multiple
> ### Title: Draw matrix of type probabilities, before or after estimation
> ### Aliases: get_type_prob_multiple
> 
> ### ** Examples
> 
> model <- make_model('X -> Y')
> get_type_prob_multiple(model, using = 'priors', n_draws = 3)
Prior distribution added to model
              [,1]       [,2]       [,3]
X0.Y00 0.048657901 0.10128077 0.12536512
X1.Y00 0.590388748 0.04693163 0.11878296
X0.Y10 0.015106908 0.15274359 0.16923890
X1.Y10 0.183299084 0.07077855 0.16035318
X0.Y01 0.004650377 0.02222317 0.14996940
X1.Y01 0.056425171 0.01029780 0.14209541
X0.Y11 0.007726205 0.40710129 0.06890644
X1.Y11 0.093745606 0.18864320 0.06528858
> get_type_prob_multiple(model, using = 'parameters', n_draws = 3)
X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11 
 0.125  0.125  0.125  0.125  0.125  0.125  0.125  0.125 
> 
> 
> 
> cleanEx()
> nameEx("get_types")
> ### * get_types
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_types
> ### Title: Get values of types according to a query
> ### Aliases: get_types
> 
> ### ** Examples
> 
> model <- make_model('X -> M -> Y; X->Y')
> query <- '(Y[X=1] > Y[X=0]) & (M[X=0]==1)'
> x <- get_types(model, query)
> summary(x)

Causal types satisfying query's condition(s)  

 query =  (Y[X=1] > Y[X=0]) & (M[X=0]==1) 

X0.M10.Y0100  X1.M10.Y0100
X0.M10.Y1100  X1.M10.Y1100
X0.M11.Y0001  X1.M11.Y0001
X0.M11.Y1001  X1.M11.Y1001
X0.M10.Y0101  X1.M10.Y0101
X0.M11.Y0101  X1.M11.Y0101
X0.M10.Y1101  X1.M10.Y1101
X0.M11.Y1101  X1.M11.Y1101


 Number of causal types that meet condition(s) =  16
 Total number of causal types in model =  128> 
> query <- 'Y[M=M[X=0], X=1]==1'
> x <- get_types(model, query)
> get_types(model, query)

Causal types satisfying query's condition(s)  

 query =  Y[M=M[X=0], X=1]==1 

X0.M00.Y0100  X1.M00.Y0100
X0.M01.Y0100  X1.M01.Y0100
X0.M00.Y1100  X1.M00.Y1100
X0.M01.Y1100  X1.M01.Y1100
X0.M00.Y0110  X1.M00.Y0110
X0.M01.Y0110  X1.M01.Y0110
X0.M00.Y1110  X1.M00.Y1110
X0.M01.Y1110  X1.M01.Y1110
X0.M10.Y0001  X1.M10.Y0001
X0.M11.Y0001  X1.M11.Y0001
X0.M10.Y1001  X1.M10.Y1001
X0.M11.Y1001  X1.M11.Y1001
X0.M00.Y0101  X1.M00.Y0101
X0.M10.Y0101  X1.M10.Y0101
X0.M01.Y0101  X1.M01.Y0101
X0.M11.Y0101  X1.M11.Y0101
X0.M00.Y1101  X1.M00.Y1101
X0.M10.Y1101  X1.M10.Y1101
X0.M01.Y1101  X1.M01.Y1101
X0.M11.Y1101  X1.M11.Y1101
X0.M10.Y0011  X1.M10.Y0011
X0.M11.Y0011  X1.M11.Y0011
X0.M10.Y1011  X1.M10.Y1011
X0.M11.Y1011  X1.M11.Y1011
X0.M00.Y0111  X1.M00.Y0111
X0.M10.Y0111  X1.M10.Y0111
X0.M01.Y0111  X1.M01.Y0111
X0.M11.Y0111  X1.M11.Y0111
X0.M00.Y1111  X1.M00.Y1111
X0.M10.Y1111  X1.M10.Y1111
X0.M01.Y1111  X1.M01.Y1111
X0.M11.Y1111  X1.M11.Y1111


 Number of causal types that meet condition(s) =  64
 Total number of causal types in model =  128> 
> query <- '(Y[X=1, M = 1] >  Y[X=0, M = 1]) & (Y[X=1, M = 0] >  Y[X=0, M = 0])'
> get_types(model, query)

Causal types satisfying query's condition(s)  

 query =  (Y[X=1, M = 1] >  Y[X=0, M = 1]) & (Y[X=1, M = 0] >  Y[X=0, M = 0]) 

X0.M00.Y0101  X1.M00.Y0101
X0.M10.Y0101  X1.M10.Y0101
X0.M01.Y0101  X1.M01.Y0101
X0.M11.Y0101  X1.M11.Y0101


 Number of causal types that meet condition(s) =  8
 Total number of causal types in model =  128> 
> query <- 'Y[X=1] == Y[X=0]'
> get_types(model, query)

Causal types satisfying query's condition(s)  

 query =  Y[X=1] == Y[X=0] 

X0.M00.Y0000  X1.M00.Y0000
X0.M10.Y0000  X1.M10.Y0000
X0.M01.Y0000  X1.M01.Y0000
X0.M11.Y0000  X1.M11.Y0000
X0.M10.Y1000  X1.M10.Y1000
X0.M11.Y1000  X1.M11.Y1000
X0.M01.Y0100  X1.M01.Y0100
X0.M11.Y0100  X1.M11.Y0100
X0.M00.Y1100  X1.M00.Y1100
X0.M11.Y1100  X1.M11.Y1100
X0.M00.Y0010  X1.M00.Y0010
X0.M01.Y0010  X1.M01.Y0010
X0.M10.Y0110  X1.M10.Y0110
X0.M01.Y0110  X1.M01.Y0110
X0.M00.Y1110  X1.M00.Y1110
X0.M10.Y1110  X1.M10.Y1110
X0.M00.Y0001  X1.M00.Y0001
X0.M10.Y0001  X1.M10.Y0001
X0.M10.Y1001  X1.M10.Y1001
X0.M01.Y1001  X1.M01.Y1001
X0.M00.Y1101  X1.M00.Y1101
X0.M01.Y1101  X1.M01.Y1101
X0.M00.Y0011  X1.M00.Y0011
X0.M11.Y0011  X1.M11.Y0011
X0.M01.Y1011  X1.M01.Y1011
X0.M11.Y1011  X1.M11.Y1011
X0.M10.Y0111  X1.M10.Y0111
X0.M11.Y0111  X1.M11.Y0111
X0.M00.Y1111  X1.M00.Y1111
X0.M10.Y1111  X1.M10.Y1111
X0.M01.Y1111  X1.M01.Y1111
X0.M11.Y1111  X1.M11.Y1111


 Number of causal types that meet condition(s) =  64
 Total number of causal types in model =  128> 
> query <- '(X == 1) & (M==1) & (Y ==1) & (Y[X=0] ==1)'
> x <- get_types(model, query)
> 
> query <- '(Y[X = .]==1)'
> get_types(model, query)
Generated expanded expression:
(Y[X=0]==1 | Y[X=1]==1)

Causal types satisfying query's condition(s)  

 query =  (Y[X=0]==1 | Y[X=1]==1) 

X0.M00.Y1000  X1.M00.Y1000
X0.M01.Y1000  X1.M01.Y1000
X0.M00.Y0100  X1.M00.Y0100
X0.M10.Y0100  X1.M10.Y0100
X0.M00.Y1100  X1.M00.Y1100
X0.M10.Y1100  X1.M10.Y1100
X0.M01.Y1100  X1.M01.Y1100
X0.M10.Y0010  X1.M10.Y0010
X0.M11.Y0010  X1.M11.Y0010
X0.M00.Y1010  X1.M00.Y1010
X0.M10.Y1010  X1.M10.Y1010
X0.M01.Y1010  X1.M01.Y1010
X0.M11.Y1010  X1.M11.Y1010
X0.M00.Y0110  X1.M00.Y0110
X0.M10.Y0110  X1.M10.Y0110
X0.M11.Y0110  X1.M11.Y0110
X0.M00.Y1110  X1.M00.Y1110
X0.M10.Y1110  X1.M10.Y1110
X0.M01.Y1110  X1.M01.Y1110
X0.M11.Y1110  X1.M11.Y1110
X0.M01.Y0001  X1.M01.Y0001
X0.M11.Y0001  X1.M11.Y0001
X0.M00.Y1001  X1.M00.Y1001
X0.M01.Y1001  X1.M01.Y1001
X0.M11.Y1001  X1.M11.Y1001
X0.M00.Y0101  X1.M00.Y0101
X0.M10.Y0101  X1.M10.Y0101
X0.M01.Y0101  X1.M01.Y0101
X0.M11.Y0101  X1.M11.Y0101
X0.M00.Y1101  X1.M00.Y1101
X0.M10.Y1101  X1.M10.Y1101
X0.M01.Y1101  X1.M01.Y1101
X0.M11.Y1101  X1.M11.Y1101
X0.M10.Y0011  X1.M10.Y0011
X0.M01.Y0011  X1.M01.Y0011
X0.M11.Y0011  X1.M11.Y0011
X0.M00.Y1011  X1.M00.Y1011
X0.M10.Y1011  X1.M10.Y1011
X0.M01.Y1011  X1.M01.Y1011
X0.M11.Y1011  X1.M11.Y1011
X0.M00.Y0111  X1.M00.Y0111
X0.M10.Y0111  X1.M10.Y0111
X0.M01.Y0111  X1.M01.Y0111
X0.M11.Y0111  X1.M11.Y0111
X0.M00.Y1111  X1.M00.Y1111
X0.M10.Y1111  X1.M10.Y1111
X0.M01.Y1111  X1.M01.Y1111
X0.M11.Y1111  X1.M11.Y1111


 Number of causal types that meet condition(s) =  96
 Total number of causal types in model =  128> 
> 
> 
> cleanEx()
> nameEx("increasing")
> ### * increasing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: increasing
> ### Title: Make monotonicity statement (positive)
> ### Aliases: increasing
> 
> ### ** Examples
> 
> increasing('A', 'B')
[1] "(B[A=1] > B[A=0])"
attr(,"class")
[1] "statement"
> 
> 
> 
> 
> cleanEx()
> nameEx("interacts")
> ### * interacts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interacts
> ### Title: Make statement for any interaction
> ### Aliases: interacts
> 
> ### ** Examples
> 
> interacts('A', 'B', 'W')
[1] "((W[A =1, B = 1]) - (W[A = 0, B = 1])) != ((W[A =1, B = 0]) - (W[A = 0, B = 0]))"
attr(,"class")
[1] "statement"
> get_query_types(model = make_model('X-> Y <- W'),
+          query = interacts('X', 'W', 'Y'))

Causal types satisfying query's condition(s)  

 query =  ((Y[X =1, W = 1]) - (Y[X = 0, W = 1])) != ((Y[X =1, W = 0]) - (Y[X = 0, W = 0])) 

W0.X0.Y1000  W1.X0.Y1000
W0.X1.Y1000  W1.X1.Y1000
W0.X0.Y0100  W1.X0.Y0100
W0.X1.Y0100  W1.X1.Y0100
W0.X0.Y0010  W1.X0.Y0010
W0.X1.Y0010  W1.X1.Y0010
W0.X0.Y0110  W1.X0.Y0110
W0.X1.Y0110  W1.X1.Y0110
W0.X0.Y1110  W1.X0.Y1110
W0.X1.Y1110  W1.X1.Y1110
W0.X0.Y0001  W1.X0.Y0001
W0.X1.Y0001  W1.X1.Y0001
W0.X0.Y1001  W1.X0.Y1001
W0.X1.Y1001  W1.X1.Y1001
W0.X0.Y1101  W1.X0.Y1101
W0.X1.Y1101  W1.X1.Y1101
W0.X0.Y1011  W1.X0.Y1011
W0.X1.Y1011  W1.X1.Y1011
W0.X0.Y0111  W1.X0.Y0111
W0.X1.Y0111  W1.X1.Y0111


 Number of causal types that meet condition(s) =  40
 Total number of causal types in model =  64> 
> 
> 
> 
> cleanEx()
> nameEx("interpret_type")
> ### * interpret_type
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interpret_type
> ### Title: Interpret or find position in nodal type
> ### Aliases: interpret_type
> 
> ### ** Examples
> 
> model <- make_model('R -> X; Z -> X; X -> Y')
> #Example using digit position
> interpret_type(model, position = list(X = c(3,4), Y = 1))
$X
  node position display    interpretation
1    X        3 X**[*]* X | R = 0 & Z = 1
2    X        4 X***[*] X | R = 1 & Z = 1

$Y
  node position display interpretation
1    Y        1   Y[*]*      Y | X = 0

> #Example using condition
> interpret_type(model, condition = c('X | Z=0 & R=1', 'X | Z=0 & R=0'))
$X
  node position display    interpretation
1    X        1 X[*]*** X | R = 0 & Z = 0
2    X        2 X*[*]** X | R = 1 & Z = 0

> #Return interpretation of all digit positions of all nodes
> interpret_type(model)
$R
  node position display interpretation
1    R       NA      R0          R = 0
2    R       NA      R1          R = 1

$Z
  node position display interpretation
1    Z       NA      Z0          Z = 0
2    Z       NA      Z1          Z = 1

$X
  node position display    interpretation
1    X        1 X[*]*** X | R = 0 & Z = 0
2    X        2 X*[*]** X | R = 1 & Z = 0
3    X        3 X**[*]* X | R = 0 & Z = 1
4    X        4 X***[*] X | R = 1 & Z = 1

$Y
  node position display interpretation
1    Y        1   Y[*]*      Y | X = 0
2    Y        2   Y*[*]      Y | X = 1

> 
> 
> 
> cleanEx()
> nameEx("lookup_nodal_type")
> ### * lookup_nodal_type
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lookup_nodal_type
> ### Title: Lookup nodal types according to a query
> ### Aliases: lookup_nodal_type
> 
> ### ** Examples
> 
> model <- make_model('X->Y')
> 
> lookup_nodal_type(model, '(Y[X=0] > Y[X=1])')

Nodal types satisfying query's condition(s)

 query :  (Y[X=0] > Y[X=1]) 

 10   


 Number of nodal types that meet query =  1
 Total number of nodal types related to Y =  4> lookup_nodal_type(model, '(Y[X=0] >= Y[X=1])')

Nodal types satisfying query's condition(s)

 query :  (Y[X=0] >= Y[X=1]) 

 00   10
 11   


 Number of nodal types that meet query =  3
 Total number of nodal types related to Y =  4> 
> model <- make_model('X -> M -> Y; X->Y')
> query <- '(Y[X=0] > Y[X=1])'
> x <- lookup_nodal_type(model, query)
> 
> query <- '(Y[X=0, M = .] > Y[X=1, M = 0])'
> x <- lookup_nodal_type(model, query)
> 
> 
> query <- '(Y[] == 1)'
> x <- lookup_nodal_type(model, query)
> x <- lookup_nodal_type(model, query, join_by = '&')
> 
> query <- '(X == 1)'
> x <- lookup_nodal_type(model, query)
> 
> query <- '(M[X=1] == M[X=0])'
> x <- lookup_nodal_type(model, query)
> 
> # Complements
> model <- make_model('M->Y; X->Y')
> query <- complements('X', 'M', 'Y')
> lookup_nodal_type(model, query)

Nodal types satisfying query's condition(s)

 query :  ((Y[X =1, M = 1]) - (Y[X = 0, M = 1])) > ((Y[X =1, M = 0]) - (Y[X = 0, M = 0])) 

 1000   0001
 1001   1101
 1011   


 Number of nodal types that meet query =  5
 Total number of nodal types related to Y =  16> 
> 
> 
> cleanEx()
> nameEx("make_ambiguities_matrix")
> ### * make_ambiguities_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_ambiguities_matrix
> ### Title: Make ambiguities matrix
> ### Aliases: make_ambiguities_matrix
> 
> ### ** Examples
> 
> model <- make_model('X -> Y')
> make_ambiguities_matrix(model = model)
      X0Y0 X1Y0 X0Y1 X1Y1
X0Y00    1    0    0    0
X1Y00    0    1    0    0
X0Y10    0    0    1    0
X1Y10    0    1    0    0
X0Y01    1    0    0    0
X1Y01    0    0    0    1
X0Y11    0    0    1    0
X1Y11    0    0    0    1
> 
> 
> 
> 
> cleanEx()
> nameEx("make_confounds_df")
> ### * make_confounds_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_confounds_df
> ### Title: Make a confounds dataframe
> ### Aliases: make_confounds_df
> 
> ### ** Examples
> 
> model <- make_model('X -> Y') %>%
+ set_confound('X <-> Y', add_confounds_df  = FALSE)
> make_confounds_df(model)
  X1 X2
1  X  Y
> 
> model <- make_model('X -> M -> Y; X <-> Y') %>%
+ set_restrictions(c('M[X=1] == M[X=0]', 'Y[M=1]==Y[M=0]'))
> make_confounds_df(model)
  X1 X2
1  X  Y
> 
> model <- make_model('X -> M -> Y; X <-> M; M <-> Y') %>%
+ set_restrictions(c('M[X=1] == M[X=0]', 'Y[M=1]==Y[M=0]'))
> make_confounds_df(model)
  X1 X2
1  X  M
2  M  Y
> 
> # The implied confounding is between X and M and also between X and Y
> model <- make_model('X -> M -> Y') %>%
+   set_confound(list(X = 'Y[X=1] > Y[X=0]'), add_confounds_df = FALSE)
> make_confounds_df(model)
  X1 X2
1  X  M
2  X  Y
> 
> model <- make_model('X -> M -> Y')
> make_confounds_df(model)
No confounding
NULL
> 
> # Bad case
> ## Not run: 
> ##D model <- make_model('X -> Y') %>%
> ##D   set_confound(list(X = 'X==1'))
> ## End(Not run)
> 
> # Complex confounding 1
> model <- make_model('A -> X <- B ; A <-> X; B <-> X')
> model$confounds_df
  X1 X2
1  A  X
2  B  X
> 
> # Complex confounding 2
> model <- make_model('A <- X -> B; A <-> X; B <-> X') %>%
+ set_restrictions(c('A[X=0] == A[X=1]', 'B[X=0] == B[X=1]'))
> table(model$parameters_df$param_set)

A_0 A_1 B_0 B_1   X 
  2   2   2   2   2 
> model$confounds_df
  X1 X2
1  X  A
2  X  B
> 
> # Full confounding: X, A|X, B|A,X with 7 degrees of freedom
> model <- make_model('A <- X -> B; A <-> X; B <-> X; A<->B') %>%
+ set_restrictions(c('A[X=0] == A[X=1]', 'B[X=0] == B[X=1]'))
> table(model$parameters_df$param_set)

 A_0  A_1  B_1 B_10  B_2  B_9    X 
   2    2    2    2    2    2    2 
> model$confounds_df
  X1 X2
1  X  A
2  X  B
3  A  B
> 
> 
> 
> cleanEx()
> nameEx("make_data")
> ### * make_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_data
> ### Title: Make data
> ### Aliases: make_data
> 
> ### ** Examples
> 
> 
> 
> # Simple draws
> model <- make_model("X -> M -> Y")
> make_data(model)
  X M Y
1 1 1 0
> make_data(model, n = 3, nodes = c("X","Y"))
Step 1: Observe X, Y (prob = 1), given TRUE
  X  M Y
1 0 NA 0
2 1 NA 0
3 1 NA 1
> make_data(model, n = 3, param_type = "prior_draw")
  X M Y
1 1 0 1
2 1 0 1
3 1 0 1
> make_data(model, n = 10, param_type = "define", alpha =  0:9)
   X M Y
1  1 0 0
2  1 0 0
3  1 1 0
4  1 1 0
5  1 1 0
6  1 1 0
7  1 1 1
8  1 1 1
9  1 1 1
10 1 1 1
> 
> # Data Strategies
> # A strategy in which X, Y are observed for sure and M is observed
> # with 50% probability for X=1, Y=0 cases
> 
> model <- make_model("X -> M -> Y")
> make_data(
+   model,
+   n = 8,
+   nodes = list(c("X", "Y"), "M"),
+   probs = list(1, .5),
+   subsets = list(NULL, "X==1 & Y==0"))
Step 1: Observe X, Y (prob = 1)
Step 2: Observe M (prob = 0.5), given X==1 & Y==0
  X  M Y
1 0 NA 0
2 0 NA 1
3 0 NA 1
4 0 NA 0
5 1  0 0
6 1 NA 0
7 1 NA 1
8 1 NA 1
> 
> # Simulate multiple datasets is fastest if w is provided
> model <- make_model("X -> Y")
> w <- get_event_prob(model)
> replicate(5, make_data_single(model, n = 5, w = w))
  [,1]      [,2]      [,3]      [,4]      [,5]     
X Numeric,5 Numeric,5 Numeric,5 Numeric,5 Numeric,5
Y Numeric,5 Numeric,5 Numeric,5 Numeric,5 Numeric,5
> 
> 
> 
> 
> cleanEx()
> nameEx("make_data_single")
> ### * make_data_single
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_data_single
> ### Title: Generate full dataset
> ### Aliases: make_data_single
> 
> ### ** Examples
> 
> 
> model <- make_model("X -> Y")
> 
> # Simplest behavior uses by default  the parameter vector contained in model,
> # which is flat by default:
> make_data_single(model, n = 5)
  X Y
1 0 0
2 0 1
3 0 1
4 1 0
5 1 1
> 
> make_data_single(model, n = 5, param_type = "prior_draw")
  X Y
1 0 0
2 1 0
3 1 0
4 1 1
5 1 1
> 
> # Simulate multiple datasets is fastest if w is provided
> w <- get_event_prob(model)
> replicate(5, make_data_single(model, n = 5, w = w))
  [,1]      [,2]      [,3]      [,4]      [,5]     
X Numeric,5 Numeric,5 Numeric,5 Numeric,5 Numeric,5
Y Numeric,5 Numeric,5 Numeric,5 Numeric,5 Numeric,5
> 
> 
> 
> 
> cleanEx()
> nameEx("make_model")
> ### * make_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_model
> ### Title: Make a model
> ### Aliases: make_model
> 
> ### ** Examples
> 
> make_model(statement = "X -> Y")

Statement: 
[1] "X -> Y"

DAG: 
  parent children
1      X        Y

 ------------------------------------------------------------------------------------------

Nodal types: 
$X
0  1

  node position display interpretation
1    X       NA      X0          X = 0
2    X       NA      X1          X = 1

$Y
00  10  01  11

  node position display interpretation
1    Y        1   Y[*]*      Y | X = 0
2    Y        2   Y*[*]      Y | X = 1


Number of types by node
X Y 
2 4 

Number of unit types:  8
> modelXKY <- make_model("X -> K -> Y; X -> Y")
> 
> # Example where cyclicaly dag attempted
> ## Not run: 
> ##D  modelXKX <- make_model("X -> K -> X")
> ## End(Not run)
> 
> # Examples with confounding
> model <- make_model("X->Y; X <-> Y")
> model$P
       X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11
X.0         1      0      1      0      1      0      1      0
X.1         0      1      0      1      0      1      0      1
Y_0.00      1      0      0      0      0      0      0      0
Y_0.10      0      0      1      0      0      0      0      0
Y_0.01      0      0      0      0      1      0      0      0
Y_0.11      0      0      0      0      0      0      1      0
Y_1.00      0      1      0      0      0      0      0      0
Y_1.10      0      0      0      1      0      0      0      0
Y_1.01      0      0      0      0      0      1      0      0
Y_1.11      0      0      0      0      0      0      0      1
> model <- make_model("Y2 <- X -> Y1; X <-> Y1; X <-> Y2")
> model$P
        X0.Y100.Y200 X1.Y100.Y200 X0.Y110.Y200 X1.Y110.Y200 X0.Y101.Y200
X.0                1            0            1            0            1
X.1                0            1            0            1            0
Y1_0.00            1            0            0            0            0
Y1_0.10            0            0            1            0            0
Y1_0.01            0            0            0            0            1
Y1_0.11            0            0            0            0            0
Y1_1.00            0            1            0            0            0
Y1_1.10            0            0            0            1            0
Y1_1.01            0            0            0            0            0
Y1_1.11            0            0            0            0            0
Y2_0.00            1            0            1            0            1
Y2_0.10            0            0            0            0            0
Y2_0.01            0            0            0            0            0
Y2_0.11            0            0            0            0            0
Y2_1.00            0            1            0            1            0
Y2_1.10            0            0            0            0            0
Y2_1.01            0            0            0            0            0
Y2_1.11            0            0            0            0            0
        X1.Y101.Y200 X0.Y111.Y200 X1.Y111.Y200 X0.Y100.Y210 X1.Y100.Y210
X.0                0            1            0            1            0
X.1                1            0            1            0            1
Y1_0.00            0            0            0            1            0
Y1_0.10            0            0            0            0            0
Y1_0.01            0            0            0            0            0
Y1_0.11            0            1            0            0            0
Y1_1.00            0            0            0            0            1
Y1_1.10            0            0            0            0            0
Y1_1.01            1            0            0            0            0
Y1_1.11            0            0            1            0            0
Y2_0.00            0            1            0            0            0
Y2_0.10            0            0            0            1            0
Y2_0.01            0            0            0            0            0
Y2_0.11            0            0            0            0            0
Y2_1.00            1            0            1            0            0
Y2_1.10            0            0            0            0            1
Y2_1.01            0            0            0            0            0
Y2_1.11            0            0            0            0            0
        X0.Y110.Y210 X1.Y110.Y210 X0.Y101.Y210 X1.Y101.Y210 X0.Y111.Y210
X.0                1            0            1            0            1
X.1                0            1            0            1            0
Y1_0.00            0            0            0            0            0
Y1_0.10            1            0            0            0            0
Y1_0.01            0            0            1            0            0
Y1_0.11            0            0            0            0            1
Y1_1.00            0            0            0            0            0
Y1_1.10            0            1            0            0            0
Y1_1.01            0            0            0            1            0
Y1_1.11            0            0            0            0            0
Y2_0.00            0            0            0            0            0
Y2_0.10            1            0            1            0            1
Y2_0.01            0            0            0            0            0
Y2_0.11            0            0            0            0            0
Y2_1.00            0            0            0            0            0
Y2_1.10            0            1            0            1            0
Y2_1.01            0            0            0            0            0
Y2_1.11            0            0            0            0            0
        X1.Y111.Y210 X0.Y100.Y201 X1.Y100.Y201 X0.Y110.Y201 X1.Y110.Y201
X.0                0            1            0            1            0
X.1                1            0            1            0            1
Y1_0.00            0            1            0            0            0
Y1_0.10            0            0            0            1            0
Y1_0.01            0            0            0            0            0
Y1_0.11            0            0            0            0            0
Y1_1.00            0            0            1            0            0
Y1_1.10            0            0            0            0            1
Y1_1.01            0            0            0            0            0
Y1_1.11            1            0            0            0            0
Y2_0.00            0            0            0            0            0
Y2_0.10            0            0            0            0            0
Y2_0.01            0            1            0            1            0
Y2_0.11            0            0            0            0            0
Y2_1.00            0            0            0            0            0
Y2_1.10            1            0            0            0            0
Y2_1.01            0            0            1            0            1
Y2_1.11            0            0            0            0            0
        X0.Y101.Y201 X1.Y101.Y201 X0.Y111.Y201 X1.Y111.Y201 X0.Y100.Y211
X.0                1            0            1            0            1
X.1                0            1            0            1            0
Y1_0.00            0            0            0            0            1
Y1_0.10            0            0            0            0            0
Y1_0.01            1            0            0            0            0
Y1_0.11            0            0            1            0            0
Y1_1.00            0            0            0            0            0
Y1_1.10            0            0            0            0            0
Y1_1.01            0            1            0            0            0
Y1_1.11            0            0            0            1            0
Y2_0.00            0            0            0            0            0
Y2_0.10            0            0            0            0            0
Y2_0.01            1            0            1            0            0
Y2_0.11            0            0            0            0            1
Y2_1.00            0            0            0            0            0
Y2_1.10            0            0            0            0            0
Y2_1.01            0            1            0            1            0
Y2_1.11            0            0            0            0            0
        X1.Y100.Y211 X0.Y110.Y211 X1.Y110.Y211 X0.Y101.Y211 X1.Y101.Y211
X.0                0            1            0            1            0
X.1                1            0            1            0            1
Y1_0.00            0            0            0            0            0
Y1_0.10            0            1            0            0            0
Y1_0.01            0            0            0            1            0
Y1_0.11            0            0            0            0            0
Y1_1.00            1            0            0            0            0
Y1_1.10            0            0            1            0            0
Y1_1.01            0            0            0            0            1
Y1_1.11            0            0            0            0            0
Y2_0.00            0            0            0            0            0
Y2_0.10            0            0            0            0            0
Y2_0.01            0            0            0            0            0
Y2_0.11            0            1            0            1            0
Y2_1.00            0            0            0            0            0
Y2_1.10            0            0            0            0            0
Y2_1.01            0            0            0            0            0
Y2_1.11            1            0            1            0            1
        X0.Y111.Y211 X1.Y111.Y211
X.0                1            0
X.1                0            1
Y1_0.00            0            0
Y1_0.10            0            0
Y1_0.01            0            0
Y1_0.11            1            0
Y1_1.00            0            0
Y1_1.10            0            0
Y1_1.01            0            0
Y1_1.11            0            1
Y2_0.00            0            0
Y2_0.10            0            0
Y2_0.01            0            0
Y2_0.11            1            0
Y2_1.00            0            0
Y2_1.10            0            0
Y2_1.01            0            0
Y2_1.11            0            1
> model$confounds_df
  X1 X2
1  X Y1
2  X Y2
> dim(model$P)
[1] 18 32
> model$P
        X0.Y100.Y200 X1.Y100.Y200 X0.Y110.Y200 X1.Y110.Y200 X0.Y101.Y200
X.0                1            0            1            0            1
X.1                0            1            0            1            0
Y1_0.00            1            0            0            0            0
Y1_0.10            0            0            1            0            0
Y1_0.01            0            0            0            0            1
Y1_0.11            0            0            0            0            0
Y1_1.00            0            1            0            0            0
Y1_1.10            0            0            0            1            0
Y1_1.01            0            0            0            0            0
Y1_1.11            0            0            0            0            0
Y2_0.00            1            0            1            0            1
Y2_0.10            0            0            0            0            0
Y2_0.01            0            0            0            0            0
Y2_0.11            0            0            0            0            0
Y2_1.00            0            1            0            1            0
Y2_1.10            0            0            0            0            0
Y2_1.01            0            0            0            0            0
Y2_1.11            0            0            0            0            0
        X1.Y101.Y200 X0.Y111.Y200 X1.Y111.Y200 X0.Y100.Y210 X1.Y100.Y210
X.0                0            1            0            1            0
X.1                1            0            1            0            1
Y1_0.00            0            0            0            1            0
Y1_0.10            0            0            0            0            0
Y1_0.01            0            0            0            0            0
Y1_0.11            0            1            0            0            0
Y1_1.00            0            0            0            0            1
Y1_1.10            0            0            0            0            0
Y1_1.01            1            0            0            0            0
Y1_1.11            0            0            1            0            0
Y2_0.00            0            1            0            0            0
Y2_0.10            0            0            0            1            0
Y2_0.01            0            0            0            0            0
Y2_0.11            0            0            0            0            0
Y2_1.00            1            0            1            0            0
Y2_1.10            0            0            0            0            1
Y2_1.01            0            0            0            0            0
Y2_1.11            0            0            0            0            0
        X0.Y110.Y210 X1.Y110.Y210 X0.Y101.Y210 X1.Y101.Y210 X0.Y111.Y210
X.0                1            0            1            0            1
X.1                0            1            0            1            0
Y1_0.00            0            0            0            0            0
Y1_0.10            1            0            0            0            0
Y1_0.01            0            0            1            0            0
Y1_0.11            0            0            0            0            1
Y1_1.00            0            0            0            0            0
Y1_1.10            0            1            0            0            0
Y1_1.01            0            0            0            1            0
Y1_1.11            0            0            0            0            0
Y2_0.00            0            0            0            0            0
Y2_0.10            1            0            1            0            1
Y2_0.01            0            0            0            0            0
Y2_0.11            0            0            0            0            0
Y2_1.00            0            0            0            0            0
Y2_1.10            0            1            0            1            0
Y2_1.01            0            0            0            0            0
Y2_1.11            0            0            0            0            0
        X1.Y111.Y210 X0.Y100.Y201 X1.Y100.Y201 X0.Y110.Y201 X1.Y110.Y201
X.0                0            1            0            1            0
X.1                1            0            1            0            1
Y1_0.00            0            1            0            0            0
Y1_0.10            0            0            0            1            0
Y1_0.01            0            0            0            0            0
Y1_0.11            0            0            0            0            0
Y1_1.00            0            0            1            0            0
Y1_1.10            0            0            0            0            1
Y1_1.01            0            0            0            0            0
Y1_1.11            1            0            0            0            0
Y2_0.00            0            0            0            0            0
Y2_0.10            0            0            0            0            0
Y2_0.01            0            1            0            1            0
Y2_0.11            0            0            0            0            0
Y2_1.00            0            0            0            0            0
Y2_1.10            1            0            0            0            0
Y2_1.01            0            0            1            0            1
Y2_1.11            0            0            0            0            0
        X0.Y101.Y201 X1.Y101.Y201 X0.Y111.Y201 X1.Y111.Y201 X0.Y100.Y211
X.0                1            0            1            0            1
X.1                0            1            0            1            0
Y1_0.00            0            0            0            0            1
Y1_0.10            0            0            0            0            0
Y1_0.01            1            0            0            0            0
Y1_0.11            0            0            1            0            0
Y1_1.00            0            0            0            0            0
Y1_1.10            0            0            0            0            0
Y1_1.01            0            1            0            0            0
Y1_1.11            0            0            0            1            0
Y2_0.00            0            0            0            0            0
Y2_0.10            0            0            0            0            0
Y2_0.01            1            0            1            0            0
Y2_0.11            0            0            0            0            1
Y2_1.00            0            0            0            0            0
Y2_1.10            0            0            0            0            0
Y2_1.01            0            1            0            1            0
Y2_1.11            0            0            0            0            0
        X1.Y100.Y211 X0.Y110.Y211 X1.Y110.Y211 X0.Y101.Y211 X1.Y101.Y211
X.0                0            1            0            1            0
X.1                1            0            1            0            1
Y1_0.00            0            0            0            0            0
Y1_0.10            0            1            0            0            0
Y1_0.01            0            0            0            1            0
Y1_0.11            0            0            0            0            0
Y1_1.00            1            0            0            0            0
Y1_1.10            0            0            1            0            0
Y1_1.01            0            0            0            0            1
Y1_1.11            0            0            0            0            0
Y2_0.00            0            0            0            0            0
Y2_0.10            0            0            0            0            0
Y2_0.01            0            0            0            0            0
Y2_0.11            0            1            0            1            0
Y2_1.00            0            0            0            0            0
Y2_1.10            0            0            0            0            0
Y2_1.01            0            0            0            0            0
Y2_1.11            1            0            1            0            1
        X0.Y111.Y211 X1.Y111.Y211
X.0                1            0
X.1                0            1
Y1_0.00            0            0
Y1_0.10            0            0
Y1_0.01            0            0
Y1_0.11            1            0
Y1_1.00            0            0
Y1_1.10            0            0
Y1_1.01            0            0
Y1_1.11            0            1
Y2_0.00            0            0
Y2_0.10            0            0
Y2_0.01            0            0
Y2_0.11            1            0
Y2_1.00            0            0
Y2_1.10            0            0
Y2_1.01            0            0
Y2_1.11            0            1
> model <- make_model("X1 -> Y <- X2; X1 <-> Y; X2 <-> Y")
> dim(model$P)
[1] 68 64
> model$parameters_df
   param_names param_value param_set node nodal_type gen priors
1         X1.0      0.5000        X1   X1          0   1      1
2         X1.1      0.5000        X1   X1          1   1      1
3         X2.0      0.5000        X2   X2          0   2      1
4         X2.1      0.5000        X2   X2          1   2      1
5     Y_0.0000      0.0625       Y_0    Y       0000   3      1
6     Y_0.1000      0.0625       Y_0    Y       1000   3      1
7     Y_0.0100      0.0625       Y_0    Y       0100   3      1
8     Y_0.1100      0.0625       Y_0    Y       1100   3      1
9     Y_0.0010      0.0625       Y_0    Y       0010   3      1
10    Y_0.1010      0.0625       Y_0    Y       1010   3      1
11    Y_0.0110      0.0625       Y_0    Y       0110   3      1
12    Y_0.1110      0.0625       Y_0    Y       1110   3      1
13    Y_0.0001      0.0625       Y_0    Y       0001   3      1
14    Y_0.1001      0.0625       Y_0    Y       1001   3      1
15    Y_0.0101      0.0625       Y_0    Y       0101   3      1
16    Y_0.1101      0.0625       Y_0    Y       1101   3      1
17    Y_0.0011      0.0625       Y_0    Y       0011   3      1
18    Y_0.1011      0.0625       Y_0    Y       1011   3      1
19    Y_0.0111      0.0625       Y_0    Y       0111   3      1
20    Y_0.1111      0.0625       Y_0    Y       1111   3      1
21    Y_1.0000      0.0625       Y_1    Y       0000   3      1
22    Y_1.1000      0.0625       Y_1    Y       1000   3      1
23    Y_1.0100      0.0625       Y_1    Y       0100   3      1
24    Y_1.1100      0.0625       Y_1    Y       1100   3      1
25    Y_1.0010      0.0625       Y_1    Y       0010   3      1
26    Y_1.1010      0.0625       Y_1    Y       1010   3      1
27    Y_1.0110      0.0625       Y_1    Y       0110   3      1
28    Y_1.1110      0.0625       Y_1    Y       1110   3      1
29    Y_1.0001      0.0625       Y_1    Y       0001   3      1
30    Y_1.1001      0.0625       Y_1    Y       1001   3      1
31    Y_1.0101      0.0625       Y_1    Y       0101   3      1
32    Y_1.1101      0.0625       Y_1    Y       1101   3      1
33    Y_1.0011      0.0625       Y_1    Y       0011   3      1
34    Y_1.1011      0.0625       Y_1    Y       1011   3      1
35    Y_1.0111      0.0625       Y_1    Y       0111   3      1
36    Y_1.1111      0.0625       Y_1    Y       1111   3      1
37    Y_2.0000      0.0625       Y_2    Y       0000   3      1
38    Y_2.1000      0.0625       Y_2    Y       1000   3      1
39    Y_2.0100      0.0625       Y_2    Y       0100   3      1
40    Y_2.1100      0.0625       Y_2    Y       1100   3      1
41    Y_2.0010      0.0625       Y_2    Y       0010   3      1
42    Y_2.1010      0.0625       Y_2    Y       1010   3      1
43    Y_2.0110      0.0625       Y_2    Y       0110   3      1
44    Y_2.1110      0.0625       Y_2    Y       1110   3      1
45    Y_2.0001      0.0625       Y_2    Y       0001   3      1
46    Y_2.1001      0.0625       Y_2    Y       1001   3      1
47    Y_2.0101      0.0625       Y_2    Y       0101   3      1
48    Y_2.1101      0.0625       Y_2    Y       1101   3      1
49    Y_2.0011      0.0625       Y_2    Y       0011   3      1
50    Y_2.1011      0.0625       Y_2    Y       1011   3      1
51    Y_2.0111      0.0625       Y_2    Y       0111   3      1
52    Y_2.1111      0.0625       Y_2    Y       1111   3      1
53    Y_3.0000      0.0625       Y_3    Y       0000   3      1
54    Y_3.1000      0.0625       Y_3    Y       1000   3      1
55    Y_3.0100      0.0625       Y_3    Y       0100   3      1
56    Y_3.1100      0.0625       Y_3    Y       1100   3      1
57    Y_3.0010      0.0625       Y_3    Y       0010   3      1
58    Y_3.1010      0.0625       Y_3    Y       1010   3      1
59    Y_3.0110      0.0625       Y_3    Y       0110   3      1
60    Y_3.1110      0.0625       Y_3    Y       1110   3      1
61    Y_3.0001      0.0625       Y_3    Y       0001   3      1
62    Y_3.1001      0.0625       Y_3    Y       1001   3      1
63    Y_3.0101      0.0625       Y_3    Y       0101   3      1
64    Y_3.1101      0.0625       Y_3    Y       1101   3      1
65    Y_3.0011      0.0625       Y_3    Y       0011   3      1
66    Y_3.1011      0.0625       Y_3    Y       1011   3      1
67    Y_3.0111      0.0625       Y_3    Y       0111   3      1
68    Y_3.1111      0.0625       Y_3    Y       1111   3      1
> 
> # A single node graph is also possible
> model <- make_model("X")
> plot(model)
> 
> # Unconnected nodes cannot
> ## Not run: 
> ##D  model <- make_model("X <-> Y")
> ##D  plot(model)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("make_parameter_matrix")
> ### * make_parameter_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_parameter_matrix
> ### Title: Make parameter matrix
> ### Aliases: make_parameter_matrix
> 
> ### ** Examples
> 
> model <- make_model('X -> Y')
> make_parameter_matrix(model)
     X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11
X.0       1      0      1      0      1      0      1      0
X.1       0      1      0      1      0      1      0      1
Y.00      1      1      0      0      0      0      0      0
Y.10      0      0      1      1      0      0      0      0
Y.01      0      0      0      0      1      1      0      0
Y.11      0      0      0      0      0      0      1      1
> 
> 
> 
> cleanEx()
> nameEx("make_parameters")
> ### * make_parameters
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_parameters
> ### Title: Make a 'true' parameter vector
> ### Aliases: make_parameters
> 
> ### ** Examples
> 
> 
> # Simple examples
> model <- make_model('X -> Y')
> data  <- simulate_data(model, n = 2)
> model <- update_model(model, data)

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 0 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.102 seconds (Warm-up)
Chain 1:                0.115 seconds (Sampling)
Chain 1:                0.217 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 0 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.097 seconds (Warm-up)
Chain 2:                0.09 seconds (Sampling)
Chain 2:                0.187 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 0 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.087 seconds (Warm-up)
Chain 3:                0.075 seconds (Sampling)
Chain 3:                0.162 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 0 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.087 seconds (Warm-up)
Chain 4:                0.087 seconds (Sampling)
Chain 4:                0.174 seconds (Total)
Chain 4: 
> make_parameters(model, parameters = c(.25, .75, 1.25,.25, .25, .25))
  X.0   X.1  Y.00  Y.10  Y.01  Y.11 
0.250 0.750 0.625 0.125 0.125 0.125 
> make_parameters(model, param_type = 'flat')
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
0.50 0.50 0.25 0.25 0.25 0.25 
> make_parameters(model, param_type = 'prior_draw')
      X.0       X.1      Y.00      Y.10      Y.01      Y.11 
0.7840955 0.2159045 0.2199391 0.2061640 0.2079416 0.3659553 
> make_parameters(model, param_type = 'prior_mean')
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
0.50 0.50 0.25 0.25 0.25 0.25 
> make_parameters(model, param_type = 'posterior_draw')
       X.0        X.1       Y.00       Y.10       Y.01       Y.11 
0.60044397 0.39955603 0.03162553 0.09971791 0.71455368 0.15410287 
> make_parameters(model, param_type = 'posterior_mean')
      X.0       X.1      Y.00      Y.10      Y.01      Y.11 
0.5020060 0.4979940 0.1629316 0.2319813 0.2342594 0.3708277 
> 
> # Harder examples, using \code{define} and priors arguments to define
> # specific parameters using causal syntax
> 
> make_parameters(make_model('X -> Y'),
+                statement = 'Y[X=1]>Y[X=0]', alphas = 2)
       X.0        X.1       Y.00       Y.10       Y.01       Y.11 
0.50000000 0.50000000 0.09090909 0.09090909 0.72727273 0.09090909 
> make_model('X -> Y') %>%
+    make_parameters(statement = c('Y[X=1]>Y[X=0]', 'Y[X=1]<Y[X=0]'), alphas = c(2,0))
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
 0.5  0.5  0.1  0.0  0.8  0.1 
> 
> # May be built up
> make_model('X -> Y') %>%
+   set_confound(list(X = 'Y[X=1]>Y[X=0]'))  %>%
+   set_parameters(confound = list(X='Y[X=1]>Y[X=0]', X='Y[X=1]<=Y[X=0]'),
+                  alphas = list(c(.2, .8), c(.8, .2))) %>%
+   set_parameters(statement = 'Y[X=1]>Y[X=0]', alphas = .5) %>%
+   get_parameters
X_0.0 X_0.1 X_1.0 X_1.1  Y.00  Y.10  Y.01  Y.11 
  0.8   0.2   0.2   0.8   0.2   0.2   0.4   0.2 
> 
> 
> 
> cleanEx()
> nameEx("make_prior_distribution")
> ### * make_prior_distribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_prior_distribution
> ### Title: Make a prior distribution from priors
> ### Aliases: make_prior_distribution
> 
> ### ** Examples
> 
> make_model('X -> Y') %>% make_prior_distribution(n_draws = 5)
            X.0       X.1      Y.00      Y.10       Y.01       Y.11
[1,] 0.07614139 0.9238586 0.1482124 0.2235221 0.03252097 0.59574449
[2,] 0.68334882 0.3166512 0.2441481 0.3295921 0.29206482 0.13419502
[3,] 0.51347987 0.4865201 0.3869452 0.5009050 0.04192469 0.07022503
[4,] 0.76308393 0.2369161 0.1967135 0.2435888 0.08283228 0.47686546
[5,] 0.37574002 0.6242600 0.0713293 0.4650213 0.34876419 0.11488525
> 
> 
> 
> 
> cleanEx()
> nameEx("make_priors")
> ### * make_priors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_priors
> ### Title: Make Priors
> ### Aliases: make_priors
> 
> ### ** Examples
> 
> model <- make_model('X -> M -> Y')
> make_priors(model, node = 'X', alphas = 3)
 X.0  X.1 M.00 M.10 M.01 M.11 Y.00 Y.10 Y.01 Y.11 
   3    3    1    1    1    1    1    1    1    1 
> make_priors(model, node = c('X', 'Y'), alphas = 3)
 X.0  X.1 M.00 M.10 M.01 M.11 Y.00 Y.10 Y.01 Y.11 
   3    3    1    1    1    1    3    3    3    3 
> make_priors(model, node = list('X', 'Y'), alphas = list(3, 6))
 X.0  X.1 M.00 M.10 M.01 M.11 Y.00 Y.10 Y.01 Y.11 
   3    3    1    1    1    1    6    6    6    6 
> make_priors(model, node = c('X', 'Y'), distribution = c('certainty', 'jeffreys'))
  X.0   X.1  M.00  M.10  M.01  M.11  Y.00  Y.10  Y.01  Y.11 
1e+04 1e+04 1e+00 1e+00 1e+00 1e+00 5e-01 5e-01 5e-01 5e-01 
> make_priors(model, statement = 'Y[M=1] > Y[M=0]', alphas = 3)
 X.0  X.1 M.00 M.10 M.01 M.11 Y.00 Y.10 Y.01 Y.11 
   1    1    1    1    1    1    1    1    3    1 
> make_priors(model, statement = c('Y[M=1] > Y[M=0]', 'M[X=1]== M[X=0]'), alphas = c(3, 2))
 X.0  X.1 M.00 M.10 M.01 M.11 Y.00 Y.10 Y.01 Y.11 
   1    1    2    1    1    2    1    1    3    1 
> ## Not run: 
> ##D # Error if statement seeks to
> ##D make_priors(model, statement = 'Y[X=1] > Y[X=0]', alphas = 3)
> ## End(Not run)
> model <- make_model('X->Y') %>%
+  set_confound(list(X = 'Y[X=1] > Y[X=0]', X = 'Y[X=1] < Y[X=0]'))
> make_priors(model,
+             confound = list(X='Y[X=1] > Y[X=0]',
+                             X='Y[X=1] < Y[X=0]'),
+             alphas = c(3, 6))
X_0.0 X_0.1 X_1.0 X_1.1 X_2.0 X_2.1  Y.00  Y.10  Y.01  Y.11 
    1     1     3     3     6     6     1     1     1     1 
> make_model('X -> Y') %>%
+   set_confound(list(X = 'Y[X=1]>Y[X=0]'))%>%
+   make_priors(statement = 'X==1',
+               confound = list(X = 'Y[X=1]>Y[X=0]', X = 'Y[X=1]<Y[X=0]'),
+               alphas = c(2, .5))
X_0.0 X_0.1 X_1.0 X_1.1  Y.00  Y.10  Y.01  Y.11 
  1.0   0.5   1.0   2.0   1.0   1.0   1.0   1.0 
> 
> 
> 
> cleanEx()
> nameEx("make_priors_single")
> ### * make_priors_single
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_priors_single
> ### Title: make_priors_single
> ### Aliases: make_priors_single
> 
> ### ** Examples
> 
> model <- make_model('X -> M -> Y; X->Y')
> 
> gbiqq:::make_priors_single(model, distribution = 'jeffreys')
   X.0    X.1   M.00   M.10   M.01   M.11 Y.0000 Y.1000 Y.0100 Y.1100 Y.0010 
   0.5    0.5    0.5    0.5    0.5    0.5    0.5    0.5    0.5    0.5    0.5 
Y.1010 Y.0110 Y.1110 Y.0001 Y.1001 Y.0101 Y.1101 Y.0011 Y.1011 Y.0111 Y.1111 
   0.5    0.5    0.5    0.5    0.5    0.5    0.5    0.5    0.5    0.5    0.5 
> 
> gbiqq:::make_priors_single(model, alphas = 3)
   X.0    X.1   M.00   M.10   M.01   M.11 Y.0000 Y.1000 Y.0100 Y.1100 Y.0010 
     3      3      3      3      3      3      3      3      3      3      3 
Y.1010 Y.0110 Y.1110 Y.0001 Y.1001 Y.0101 Y.1101 Y.0011 Y.1011 Y.0111 Y.1111 
     3      3      3      3      3      3      3      3      3      3      3 
> 
> # Examples of selecting subsets
> # By node
> gbiqq:::make_priors_single(model, node = 'M', alphas = 8)
   X.0    X.1   M.00   M.10   M.01   M.11 Y.0000 Y.1000 Y.0100 Y.1100 Y.0010 
     1      1      8      8      8      8      1      1      1      1      1 
Y.1010 Y.0110 Y.1110 Y.0001 Y.1001 Y.0101 Y.1101 Y.0011 Y.1011 Y.0111 Y.1111 
     1      1      1      1      1      1      1      1      1      1      1 
> 
> # By nodal type statement
> gbiqq:::make_priors_single(model,
+         statement = '(Y[X=1, M = .] > Y[X=0, M = .])', alphas = 2)
   X.0    X.1   M.00   M.10   M.01   M.11 Y.0000 Y.1000 Y.0100 Y.1100 Y.0010 
     1      1      1      1      1      1      1      1      2      1      1 
Y.1010 Y.0110 Y.1110 Y.0001 Y.1001 Y.0101 Y.1101 Y.0011 Y.1011 Y.0111 Y.1111 
     1      2      1      2      2      2      2      1      1      2      1 
> 
> # By nodal type label (safest to provide node also)
> gbiqq:::make_priors_single(model, node = 'X', label = '0', alphas = 9)
   X.0    X.1   M.00   M.10   M.01   M.11 Y.0000 Y.1000 Y.0100 Y.1100 Y.0010 
     9      1      1      1      1      1      1      1      1      1      1 
Y.1010 Y.0110 Y.1110 Y.0001 Y.1001 Y.0101 Y.1101 Y.0011 Y.1011 Y.0111 Y.1111 
     1      1      1      1      1      1      1      1      1      1      1 
> 
> # By confound query: Applies only to types that are involved in confounding
> # Only alters named node in confound, even if other nodes are listed in 'nodes'
> confounds <- list(X = 'Y[X=1] > Y[X=0]', X = 'Y[X=1] < Y[X=0]')
> model     <- make_model('X->Y') %>% set_confound(confounds)
> gbiqq:::make_priors_single(model, confound = confounds[1], alphas = 3)
X_0.0 X_0.1 X_1.0 X_1.1 X_2.0 X_2.1  Y.00  Y.10  Y.01  Y.11 
    1     1     3     3     1     1     1     1     1     1 
> gbiqq:::make_priors_single(model, node = 'Y', confound = confounds[1], alphas = 3)
X_0.0 X_0.1 X_1.0 X_1.1 X_2.0 X_2.1  Y.00  Y.10  Y.01  Y.11 
    1     1     1     1     1     1     1     1     3     1 
> 
> # A residual  confound condition can also be defined
> gbiqq:::make_priors_single(model, confound = list(X = '!(Y[X=1] > Y[X=0])'), alphas = 3)
X_0.0 X_0.1 X_1.0 X_1.1 X_2.0 X_2.1  Y.00  Y.10  Y.01  Y.11 
    3     3     1     1     3     3     1     1     1     1 
> gbiqq:::make_priors_single(model, confound = list(X = '(Y[X=1] == Y[X=0])'), alphas = 3)
X_0.0 X_0.1 X_1.0 X_1.1 X_2.0 X_2.1  Y.00  Y.10  Y.01  Y.11 
    3     3     1     1     1     1     1     1     1     1 
> 
> # make_priors_single can also be used for some vector valued statements
> model <- make_model('X -> M -> Y')
> gbiqq:::make_priors_single(model, node = c('X', 'Y'), alphas = 2)
 X.0  X.1 M.00 M.10 M.01 M.11 Y.00 Y.10 Y.01 Y.11 
   2    2    1    1    1    1    2    2    2    2 
> gbiqq:::make_priors_single(model, label = c('1', '01'), alphas = 2)
Warning in if (!is.na(label) | !is.na(nodal_type)) { :
  the condition has length > 1 and only the first element will be used
 X.0  X.1 M.00 M.10 M.01 M.11 Y.00 Y.10 Y.01 Y.11 
   1    2    1    1    2    1    1    1    2    1 
> 
> # Incompatible conditions produce no change
> # Such cases best handled by  make_priors
> gbiqq:::make_priors_single(model, node = 'X', label = '01', alphas = 2)
No change to priors
 X.0  X.1 M.00 M.10 M.01 M.11 Y.00 Y.10 Y.01 Y.11 
   1    1    1    1    1    1    1    1    1    1 
> 
> # Problematic example
> ## Not run: 
> ##D gbiqq:::make_priors_single(model, alphas = 1:2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("non_decreasing")
> ### * non_decreasing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: non_decreasing
> ### Title: Make monotonicity statement (non negative)
> ### Aliases: non_decreasing
> 
> ### ** Examples
> 
> non_decreasing('A', 'B')
[1] "(B[A=1] >= B[A=0])"
attr(,"class")
[1] "statement"
> 
> 
> 
> 
> cleanEx()
> nameEx("non_increasing")
> ### * non_increasing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: non_increasing
> ### Title: Make monotonicity statement (non positive)
> ### Aliases: non_increasing
> 
> ### ** Examples
> 
> non_increasing('A', 'B')
[1] "(B[A=1] <= B[A=0])"
attr(,"class")
[1] "statement"
> 
> 
> 
> 
> cleanEx()
> nameEx("observe_data")
> ### * observe_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: observe_data
> ### Title: Observe data, given a strategy
> ### Aliases: observe_data
> 
> ### ** Examples
> 
> model <- make_model("X -> Y")
> df <- simulate_data(model, n = 8)
> # Observe X values only
> observe_data(complete_data = df, nodes_to_observe = "X")
     X     Y
1 TRUE FALSE
2 TRUE FALSE
3 TRUE FALSE
4 TRUE FALSE
5 TRUE FALSE
6 TRUE FALSE
7 TRUE FALSE
8 TRUE FALSE
> # Observe half the Y values for cases with observed X = 1
> observe_data(complete_data = df,
+      observed = observe_data(complete_data = df, nodes_to_observe = "X"),
+      nodes_to_observe = "Y", prob = .5,
+      subset = "X==1")
     X     Y
1 TRUE FALSE
2 TRUE FALSE
3 TRUE FALSE
4 TRUE FALSE
5 TRUE  TRUE
6 TRUE FALSE
7 TRUE  TRUE
8 TRUE FALSE
> 
> 
> 
> cleanEx()
> nameEx("perm")
> ### * perm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: perm
> ### Title: Produces the possible permutations of a set of nodes
> ### Aliases: perm
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D perm(3)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plot_dag")
> ### * plot_dag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_dag
> ### Title: Plot your dag using dagitty
> ### Aliases: plot_dag
> 
> ### ** Examples
> 
> ## Not run: 
> ##D model <- make_model('X -> K -> Y; X -> Y')
> ##D plot_dag(model)
> ##D model <- make_model('X -> K -> Y; X <-> Y')
> ##D plot_dag(model)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("prep_gbiqq_data")
> ### * prep_gbiqq_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prep_gbiqq_data
> ### Title: Prepare data for stan
> ### Aliases: prep_gbiqq_data
> 
> ### ** Examples
> 
> model <- make_model('X->Y')
> data  <-  collapse_data(simulate_data(model, n = 6), model)
> prep_gbiqq_data(model, data)
$n_params
[1] 6

$n_param_sets
[1] 2

$n_param_each
X Y 
2 4 

$l_starts
X Y 
1 3 

$l_ends
X Y 
2 6 

$lambdas_prior
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
   1    1    1    1    1    1 

$n_types
[1] 8

$n_data
[1] 4

$n_events
[1] 4

$n_strategies
[1] 1

$strategy_starts
[1] 1

$strategy_ends
[1] 4

$P
     X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11
X.0       1      0      1      0      1      0      1      0
X.1       0      1      0      1      0      1      0      1
Y.00      1      1      0      0      0      0      0      0
Y.10      0      0      1      1      0      0      0      0
Y.01      0      0      0      0      1      1      0      0
Y.11      0      0      0      0      0      0      1      1

$not_P
     X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11
X.0       0      1      0      1      0      1      0      1
X.1       1      0      1      0      1      0      1      0
Y.00      0      0      1      1      1      1      1      1
Y.10      1      1      0      0      1      1      1      1
Y.01      1      1      1      1      0      0      1      1
Y.11      1      1      1      1      1      1      0      0

$A
      X0Y0 X1Y0 X0Y1 X1Y1
X0Y00    1    0    0    0
X1Y00    0    1    0    0
X0Y10    0    0    1    0
X1Y10    0    1    0    0
X0Y01    1    0    0    0
X1Y01    0    0    0    1
X0Y11    0    0    1    0
X1Y11    0    0    0    1

$E
     X0Y0 X1Y0 X0Y1 X1Y1
X0Y0    1    0    0    0
X1Y0    0    1    0    0
X0Y1    0    0    1    0
X1Y1    0    0    0    1

$Y
[1] 1 1 2 2

> 
> model <- make_model('X->Y') %>% set_confound(list(X = 'Y[X=1]>Y[X=0]'))
> data  <-  collapse_data(simulate_data(model, n = 6), model)
> prep_gbiqq_data(model, data)
$n_params
[1] 8

$n_param_sets
[1] 3

$n_param_each
X_0 X_1   Y 
  2   2   4 

$l_starts
X_0 X_1   Y 
  1   3   5 

$l_ends
X_0 X_1   Y 
  2   4   8 

$lambdas_prior
X_0.0 X_0.1 X_1.0 X_1.1  Y.00  Y.10  Y.01  Y.11 
    1     1     1     1     1     1     1     1 

$n_types
[1] 8

$n_data
[1] 4

$n_events
[1] 4

$n_strategies
[1] 1

$strategy_starts
[1] 1

$strategy_ends
[1] 4

$P
      X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11
X_0.0      1      0      1      0      0      0      1      0
X_0.1      0      1      0      1      0      0      0      1
X_1.0      0      0      0      0      1      0      0      0
X_1.1      0      0      0      0      0      1      0      0
Y.00       1      1      0      0      0      0      0      0
Y.10       0      0      1      1      0      0      0      0
Y.01       0      0      0      0      1      1      0      0
Y.11       0      0      0      0      0      0      1      1

$not_P
      X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11
X_0.0      0      1      0      1      1      1      0      1
X_0.1      1      0      1      0      1      1      1      0
X_1.0      1      1      1      1      0      1      1      1
X_1.1      1      1      1      1      1      0      1      1
Y.00       0      0      1      1      1      1      1      1
Y.10       1      1      0      0      1      1      1      1
Y.01       1      1      1      1      0      0      1      1
Y.11       1      1      1      1      1      1      0      0

$A
      X0Y0 X1Y0 X0Y1 X1Y1
X0Y00    1    0    0    0
X1Y00    0    1    0    0
X0Y10    0    0    1    0
X1Y10    0    1    0    0
X0Y01    1    0    0    0
X1Y01    0    0    0    1
X0Y11    0    0    1    0
X1Y11    0    0    0    1

$E
     X0Y0 X1Y0 X0Y1 X1Y1
X0Y0    1    0    0    0
X1Y0    0    1    0    0
X0Y1    0    0    1    0
X1Y1    0    0    0    1

$Y
[1] 3 0 3 0

> 
> 
> 
> 
> cleanEx()
> nameEx("query_distribution")
> ### * query_distribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: query_distribution
> ### Title: Calculate estimand distribution
> ### Aliases: query_distribution
> 
> ### ** Examples
> 
> model <- make_model("X -> Y") %>%
+          set_prior_distribution()
> 
>  distribution <- query_distribution(model, query = "(Y[X=1] - Y[X=0])")
>  distribution <- query_distribution(model, query = "(Y[X=1] - Y[X=0])", given = "X==1")
>  distribution <- query_distribution(model, query = "(Y[X=1] - Y[X=0])", given = "Y[X=1]==1")
>  distribution <- query_distribution(model, query = "(Y[X=1] > Y[X=0])")
>  distribution <- query_distribution(model, query = "(Y[X=.] == 1)", join_by = "&")
Generated expanded expression:
(Y[X=0] == 1 | Y[X=1] == 1)
>  distribution <- query_distribution(model, query = "(Y[X=1] - Y[X=0])", using = "parameters")
> ## Not run: 
> ##D  df    <- simulate_data(model, n = 3)
> ##D  updated_model <- gbiqq(model, df)
> ##D  query_distribution( updated_model , query = "(Y[X=1] - Y[X=0])", using = "posteriors")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("query_model")
> ### * query_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: query_model
> ### Title: Generate estimands dataframe
> ### Aliases: query_model
> 
> ### ** Examples
> 
> model <- make_model("X -> Y") %>% set_prior_distribution(n_draws = 10000)
> 
> estimands_df <-query_model(
+                model,
+                query = list(ATE = "Y[X=1] - Y[X=0]", Share_positive = "Y[X=1] > Y[X=0]"),
+                using = c("parameters", "priors"),
+                expand_grid = TRUE)
> 
> estimands_df <-query_model(
+                model,
+                query = list(ATE = "Y[X=1] - Y[X=0]", Share_positive = "Y[X=1] > Y[X=0]"),
+                using = c("parameters", "priors"),
+                expand_grid = FALSE)
> 
> estimands_df <- query_model(
+                 model,
+                 using = list( "parameters", "priors"),
+                 query = list(ATE = "Y[X=1] - Y[X=0]", Is_B = "Y[X=1] > Y[X=0]"),
+                 given = list(TRUE,  "Y==0 & X==1"),
+                 expand_grid = TRUE,
+                 digits = 3)
> 
> # An example: a stat representing uncertainty of token causation
> token_var <- function(x) mean(x)*(1-mean(x))
> estimands_df <- query_model(
+                 model,
+                 using = list( "parameters", "priors"),
+                 query = "Y[X=1] > Y[X=0]",
+                 stats = c(mean = mean, sd = sd, token_var = token_var))
> 
> 
> 
> 
> cleanEx()
> nameEx("reveal_outcomes")
> ### * reveal_outcomes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reveal_outcomes
> ### Title: Reveal outcomes
> ### Aliases: reveal_outcomes
> 
> ### ** Examples
> 
> model <- make_model("X -> Y")
> reveal_outcomes(model)
     X Y
0.00 0 0
1.00 1 0
0.10 0 1
1.10 1 0
0.01 0 0
1.01 1 1
0.11 0 1
1.11 1 1
> 
> model <- make_model("X1->Y;X2->M;M->Y")
> reveal_outcomes(model, dos = list(X1 = 1, M = 0))
            X1 X2 M Y
0.0.00.0000  1  0 0 0
1.0.00.0000  1  0 0 0
0.1.00.0000  1  1 0 0
1.1.00.0000  1  1 0 0
0.0.10.0000  1  0 0 0
1.0.10.0000  1  0 0 0
0.1.10.0000  1  1 0 0
1.1.10.0000  1  1 0 0
0.0.01.0000  1  0 0 0
1.0.01.0000  1  0 0 0
0.1.01.0000  1  1 0 0
1.1.01.0000  1  1 0 0
0.0.11.0000  1  0 0 0
1.0.11.0000  1  0 0 0
0.1.11.0000  1  1 0 0
1.1.11.0000  1  1 0 0
0.0.00.1000  1  0 0 0
1.0.00.1000  1  0 0 0
0.1.00.1000  1  1 0 0
1.1.00.1000  1  1 0 0
0.0.10.1000  1  0 0 0
1.0.10.1000  1  0 0 0
0.1.10.1000  1  1 0 0
1.1.10.1000  1  1 0 0
0.0.01.1000  1  0 0 0
1.0.01.1000  1  0 0 0
0.1.01.1000  1  1 0 0
1.1.01.1000  1  1 0 0
0.0.11.1000  1  0 0 0
1.0.11.1000  1  0 0 0
0.1.11.1000  1  1 0 0
1.1.11.1000  1  1 0 0
0.0.00.0100  1  0 0 1
1.0.00.0100  1  0 0 1
0.1.00.0100  1  1 0 1
1.1.00.0100  1  1 0 1
0.0.10.0100  1  0 0 1
1.0.10.0100  1  0 0 1
0.1.10.0100  1  1 0 1
1.1.10.0100  1  1 0 1
0.0.01.0100  1  0 0 1
1.0.01.0100  1  0 0 1
0.1.01.0100  1  1 0 1
1.1.01.0100  1  1 0 1
0.0.11.0100  1  0 0 1
1.0.11.0100  1  0 0 1
0.1.11.0100  1  1 0 1
1.1.11.0100  1  1 0 1
0.0.00.1100  1  0 0 1
1.0.00.1100  1  0 0 1
0.1.00.1100  1  1 0 1
1.1.00.1100  1  1 0 1
0.0.10.1100  1  0 0 1
1.0.10.1100  1  0 0 1
0.1.10.1100  1  1 0 1
1.1.10.1100  1  1 0 1
0.0.01.1100  1  0 0 1
1.0.01.1100  1  0 0 1
0.1.01.1100  1  1 0 1
1.1.01.1100  1  1 0 1
0.0.11.1100  1  0 0 1
1.0.11.1100  1  0 0 1
0.1.11.1100  1  1 0 1
1.1.11.1100  1  1 0 1
0.0.00.0010  1  0 0 0
1.0.00.0010  1  0 0 0
0.1.00.0010  1  1 0 0
1.1.00.0010  1  1 0 0
0.0.10.0010  1  0 0 0
1.0.10.0010  1  0 0 0
0.1.10.0010  1  1 0 0
1.1.10.0010  1  1 0 0
0.0.01.0010  1  0 0 0
1.0.01.0010  1  0 0 0
0.1.01.0010  1  1 0 0
1.1.01.0010  1  1 0 0
0.0.11.0010  1  0 0 0
1.0.11.0010  1  0 0 0
0.1.11.0010  1  1 0 0
1.1.11.0010  1  1 0 0
0.0.00.1010  1  0 0 0
1.0.00.1010  1  0 0 0
0.1.00.1010  1  1 0 0
1.1.00.1010  1  1 0 0
0.0.10.1010  1  0 0 0
1.0.10.1010  1  0 0 0
0.1.10.1010  1  1 0 0
1.1.10.1010  1  1 0 0
0.0.01.1010  1  0 0 0
1.0.01.1010  1  0 0 0
0.1.01.1010  1  1 0 0
1.1.01.1010  1  1 0 0
0.0.11.1010  1  0 0 0
1.0.11.1010  1  0 0 0
0.1.11.1010  1  1 0 0
1.1.11.1010  1  1 0 0
0.0.00.0110  1  0 0 1
1.0.00.0110  1  0 0 1
0.1.00.0110  1  1 0 1
1.1.00.0110  1  1 0 1
0.0.10.0110  1  0 0 1
1.0.10.0110  1  0 0 1
0.1.10.0110  1  1 0 1
1.1.10.0110  1  1 0 1
0.0.01.0110  1  0 0 1
1.0.01.0110  1  0 0 1
0.1.01.0110  1  1 0 1
1.1.01.0110  1  1 0 1
0.0.11.0110  1  0 0 1
1.0.11.0110  1  0 0 1
0.1.11.0110  1  1 0 1
1.1.11.0110  1  1 0 1
0.0.00.1110  1  0 0 1
1.0.00.1110  1  0 0 1
0.1.00.1110  1  1 0 1
1.1.00.1110  1  1 0 1
0.0.10.1110  1  0 0 1
1.0.10.1110  1  0 0 1
0.1.10.1110  1  1 0 1
1.1.10.1110  1  1 0 1
0.0.01.1110  1  0 0 1
1.0.01.1110  1  0 0 1
0.1.01.1110  1  1 0 1
1.1.01.1110  1  1 0 1
0.0.11.1110  1  0 0 1
1.0.11.1110  1  0 0 1
0.1.11.1110  1  1 0 1
1.1.11.1110  1  1 0 1
0.0.00.0001  1  0 0 0
1.0.00.0001  1  0 0 0
0.1.00.0001  1  1 0 0
1.1.00.0001  1  1 0 0
0.0.10.0001  1  0 0 0
1.0.10.0001  1  0 0 0
0.1.10.0001  1  1 0 0
1.1.10.0001  1  1 0 0
0.0.01.0001  1  0 0 0
1.0.01.0001  1  0 0 0
0.1.01.0001  1  1 0 0
1.1.01.0001  1  1 0 0
0.0.11.0001  1  0 0 0
1.0.11.0001  1  0 0 0
0.1.11.0001  1  1 0 0
1.1.11.0001  1  1 0 0
0.0.00.1001  1  0 0 0
1.0.00.1001  1  0 0 0
0.1.00.1001  1  1 0 0
1.1.00.1001  1  1 0 0
0.0.10.1001  1  0 0 0
1.0.10.1001  1  0 0 0
0.1.10.1001  1  1 0 0
1.1.10.1001  1  1 0 0
0.0.01.1001  1  0 0 0
1.0.01.1001  1  0 0 0
0.1.01.1001  1  1 0 0
1.1.01.1001  1  1 0 0
0.0.11.1001  1  0 0 0
1.0.11.1001  1  0 0 0
0.1.11.1001  1  1 0 0
1.1.11.1001  1  1 0 0
0.0.00.0101  1  0 0 1
1.0.00.0101  1  0 0 1
0.1.00.0101  1  1 0 1
1.1.00.0101  1  1 0 1
0.0.10.0101  1  0 0 1
1.0.10.0101  1  0 0 1
0.1.10.0101  1  1 0 1
1.1.10.0101  1  1 0 1
0.0.01.0101  1  0 0 1
1.0.01.0101  1  0 0 1
0.1.01.0101  1  1 0 1
1.1.01.0101  1  1 0 1
0.0.11.0101  1  0 0 1
1.0.11.0101  1  0 0 1
0.1.11.0101  1  1 0 1
1.1.11.0101  1  1 0 1
0.0.00.1101  1  0 0 1
1.0.00.1101  1  0 0 1
0.1.00.1101  1  1 0 1
1.1.00.1101  1  1 0 1
0.0.10.1101  1  0 0 1
1.0.10.1101  1  0 0 1
0.1.10.1101  1  1 0 1
1.1.10.1101  1  1 0 1
0.0.01.1101  1  0 0 1
1.0.01.1101  1  0 0 1
0.1.01.1101  1  1 0 1
1.1.01.1101  1  1 0 1
0.0.11.1101  1  0 0 1
1.0.11.1101  1  0 0 1
0.1.11.1101  1  1 0 1
1.1.11.1101  1  1 0 1
0.0.00.0011  1  0 0 0
1.0.00.0011  1  0 0 0
0.1.00.0011  1  1 0 0
1.1.00.0011  1  1 0 0
0.0.10.0011  1  0 0 0
1.0.10.0011  1  0 0 0
0.1.10.0011  1  1 0 0
1.1.10.0011  1  1 0 0
0.0.01.0011  1  0 0 0
1.0.01.0011  1  0 0 0
0.1.01.0011  1  1 0 0
1.1.01.0011  1  1 0 0
0.0.11.0011  1  0 0 0
1.0.11.0011  1  0 0 0
0.1.11.0011  1  1 0 0
1.1.11.0011  1  1 0 0
0.0.00.1011  1  0 0 0
1.0.00.1011  1  0 0 0
0.1.00.1011  1  1 0 0
1.1.00.1011  1  1 0 0
0.0.10.1011  1  0 0 0
1.0.10.1011  1  0 0 0
0.1.10.1011  1  1 0 0
1.1.10.1011  1  1 0 0
0.0.01.1011  1  0 0 0
1.0.01.1011  1  0 0 0
0.1.01.1011  1  1 0 0
1.1.01.1011  1  1 0 0
0.0.11.1011  1  0 0 0
1.0.11.1011  1  0 0 0
0.1.11.1011  1  1 0 0
1.1.11.1011  1  1 0 0
0.0.00.0111  1  0 0 1
1.0.00.0111  1  0 0 1
0.1.00.0111  1  1 0 1
1.1.00.0111  1  1 0 1
0.0.10.0111  1  0 0 1
1.0.10.0111  1  0 0 1
0.1.10.0111  1  1 0 1
1.1.10.0111  1  1 0 1
0.0.01.0111  1  0 0 1
1.0.01.0111  1  0 0 1
0.1.01.0111  1  1 0 1
1.1.01.0111  1  1 0 1
0.0.11.0111  1  0 0 1
1.0.11.0111  1  0 0 1
0.1.11.0111  1  1 0 1
1.1.11.0111  1  1 0 1
0.0.00.1111  1  0 0 1
1.0.00.1111  1  0 0 1
0.1.00.1111  1  1 0 1
1.1.00.1111  1  1 0 1
0.0.10.1111  1  0 0 1
1.0.10.1111  1  0 0 1
0.1.10.1111  1  1 0 1
1.1.10.1111  1  1 0 1
0.0.01.1111  1  0 0 1
1.0.01.1111  1  0 0 1
0.1.01.1111  1  1 0 1
1.1.01.1111  1  1 0 1
0.0.11.1111  1  0 0 1
1.0.11.1111  1  0 0 1
0.1.11.1111  1  1 0 1
1.1.11.1111  1  1 0 1
> 
> model <- make_model("X->M->Y")
> reveal_outcomes(model, dos = list(M = 1), node = "Y")
   M Y
00 1 0
10 1 0
01 1 1
11 1 1
> 
> 
> 
> 
> cleanEx()
> nameEx("set_confound")
> ### * set_confound
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_confound
> ### Title: Set confound
> ### Aliases: set_confound
> 
> ### ** Examples
> 
> 
> model <- make_model('X -> Y') %>%
+   set_confound(list('X <-> Y'))
> get_parameters(model)
   X.0    X.1 Y_0.00 Y_0.10 Y_0.01 Y_0.11 Y_1.00 Y_1.10 Y_1.01 Y_1.11 
  0.50   0.50   0.25   0.25   0.25   0.25   0.25   0.25   0.25   0.25 
> 
> # In this case we notionally place a distribution but in fact Y has degenerate support
> make_model('X -> Y -> Z') %>%
+   set_restrictions(c(increasing('X', 'Y')), keep = TRUE) %>%
+   set_confound(list('X <-> Y')) %>%
+   get_parameter_matrix()
       X0.Y01.Z00 X1.Y01.Z00 X0.Y01.Z10 X1.Y01.Z10 X0.Y01.Z01 X1.Y01.Z01
X.0             1          0          1          0          1          0
X.1             0          1          0          1          0          1
Y_0.01          1          0          1          0          1          0
Y_1.01          0          1          0          1          0          1
Z.00            1          1          0          0          0          0
Z.10            0          0          1          1          0          0
Z.01            0          0          0          0          1          1
Z.11            0          0          0          0          0          0
       X0.Y01.Z11 X1.Y01.Z11
X.0             1          0
X.1             0          1
Y_0.01          1          0
Y_1.01          0          1
Z.00            0          0
Z.10            0          0
Z.01            0          0
Z.11            1          1
> 
> # X nodes assigned conditional on Y
> make_model('X -> Y') %>%
+   set_confound(list(X = 'Y')) %>%
+   get_parameter_matrix()
      X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11
X_0.0      1      0      0      0      0      0      0      0
X_0.1      0      1      0      0      0      0      0      0
X_1.0      0      0      1      0      0      0      0      0
X_1.1      0      0      0      1      0      0      0      0
X_2.0      0      0      0      0      1      0      0      0
X_2.1      0      0      0      0      0      1      0      0
X_4.0      0      0      0      0      0      0      1      0
X_4.1      0      0      0      0      0      0      0      1
Y.00       1      1      0      0      0      0      0      0
Y.10       0      0      1      1      0      0      0      0
Y.01       0      0      0      0      1      1      0      0
Y.11       0      0      0      0      0      0      1      1
> 
> # Y nodes assigned conditional on X
> make_model('X -> Y') %>%
+   set_confound(list(Y = 'X')) %>%
+   get_parameter_matrix()
       X0.Y00 X1.Y00 X0.Y10 X1.Y10 X0.Y01 X1.Y01 X0.Y11 X1.Y11
X.0         1      0      1      0      1      0      1      0
X.1         0      1      0      1      0      1      0      1
Y_0.00      1      0      0      0      0      0      0      0
Y_0.10      0      0      1      0      0      0      0      0
Y_0.01      0      0      0      0      1      0      0      0
Y_0.11      0      0      0      0      0      0      1      0
Y_1.00      0      1      0      0      0      0      0      0
Y_1.10      0      0      0      1      0      0      0      0
Y_1.01      0      0      0      0      0      1      0      0
Y_1.11      0      0      0      0      0      0      0      1
> 
> model <- make_model('X -> Y') %>%
+   set_confound(list(X = '(Y[X=1]>Y[X=0])', X = '(Y[X=1]<Y[X=0])', X = '(Y[X=1]==Y[X=0])'))
> 
> model <- make_model('X -> M -> Y') %>%
+ set_confound (list(X = '(Y[X=1]>Y[X=0])',
+                  M = 'Y',
+                  X = '(Y[X=1]<Y[X=0])'))
> 
> confound = list(A = '(D[A=., B=1, C=1]>D[A=., B=0, C=0])')
> model <- make_model('A -> B -> C -> D; B -> D') %>%
+  set_confound(confound = confound)
Generated expanded expression:
(D[A=0, B=1, C=1]>D[A=0, B=0, C=0] | D[A=1, B=1, C=1]>D[A=1, B=0, C=0])
> 
> # Example where two parents are confounded
> model <- make_model('A -> B <- C') %>%
+   set_confound(list(A = 'C==1')) %>%
+   set_parameters(c(0,1,1,0, .5, .5, rep(.0625, 16)))
> cor(simulate_data(model, n = 20))
           A          C          B
A  1.0000000 -1.0000000  0.1005038
C -1.0000000  1.0000000 -0.1005038
B  0.1005038 -0.1005038  1.0000000
> 
> model <- make_model('X -> Y')
> confound <- list(X = '(Y[X=1] > Y[X=0])', X = '(Y[X=1] == 1)')
> model <- set_confound(model = model, confound = confound)
> 
> model <- make_model('X -> Y <- S; S -> W') %>%
+   set_restrictions(c(
+   increasing('X', 'Y'), increasing('S', 'W'),
+   increasing('S', 'Y'), decreasing('S', 'Y')))
> model1 <-  set_confound(model, list(X = 'S==1', S = 'W[S=1]==1'), add_confounds_df = TRUE)
> model1$confounds_df
  X1 X2
1  S  W
2  S  X
> model2 <-  set_confound(model, list(S = 'X==1', S = 'W[S=1]==1'), add_confounds_df = TRUE)
> model2$confounds_df
  X1 X2
1  S  X
2  S  W
> 
> 
> 
> cleanEx()
> nameEx("set_confounds_df")
> ### * set_confounds_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_confounds_df
> ### Title: Set a confounds_df
> ### Aliases: set_confounds_df
> 
> ### ** Examples
> 
> model <- make_model('X -> Y') %>%
+   set_confound(list('X <-> Y'), add_confounds_df = FALSE)
> model$confounds_df
NULL
> set_confounds_df(model)$confounds_df
  X1 X2
1  X  Y
> 
> # An example where a confounds dataframe needs to be updated manually
> # Here a restriction applied after a confounding relation is set removes the confounding
> model <- make_model('X -> Y') %>%
+   set_confound(list(X = '(Y[X=1] > Y[X=0])')) %>%
+   set_restrictions('(Y[X=1] > Y[X=0])')
> model$confounds_df  # Incorrect
  X1 X2
1  X  Y
> model <- set_confounds_df(model)
> model$confounds_df  # Correct
[1] NA
> # plot(model)
> 
> 
> 
> cleanEx()
> nameEx("set_parameters")
> ### * set_parameters
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_parameters
> ### Title: Set parameters
> ### Aliases: set_parameters
> 
> ### ** Examples
> 
> make_model('X->Y') %>% set_parameters(1:6) %>% get_parameters()
      X.0       X.1      Y.00      Y.10      Y.01      Y.11 
0.3333333 0.6666667 0.1666667 0.2222222 0.2777778 0.3333333 
> 
> make_model('X -> Y') %>%
+   set_confound(list(X = 'Y[X=1]>Y[X=0]'))  %>%
+   set_parameters(confound = list(X='Y[X=1]>Y[X=0]', X='Y[X=1]<=Y[X=0]'),
+                  alphas = list(c(.2, .8), c(.8, .2))) %>%
+   set_parameters(statement = 'Y[X=1]>Y[X=0]', alphas = .5) %>%
+   get_parameters
X_0.0 X_0.1 X_1.0 X_1.1  Y.00  Y.10  Y.01  Y.11 
  0.8   0.2   0.2   0.8   0.2   0.2   0.4   0.2 
> 
> 
> 
> cleanEx()
> nameEx("set_prior_distribution")
> ### * set_prior_distribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_prior_distribution
> ### Title: Add prior distribution draws
> ### Aliases: set_prior_distribution
> 
> ### ** Examples
> 
> make_model('X -> Y') %>% set_prior_distribution(n_draws = 5) %>% get_prior_distribution()
            X.0       X.1      Y.00      Y.10       Y.01       Y.11
[1,] 0.07614139 0.9238586 0.1482124 0.2235221 0.03252097 0.59574449
[2,] 0.68334882 0.3166512 0.2441481 0.3295921 0.29206482 0.13419502
[3,] 0.51347987 0.4865201 0.3869452 0.5009050 0.04192469 0.07022503
[4,] 0.76308393 0.2369161 0.1967135 0.2435888 0.08283228 0.47686546
[5,] 0.37574002 0.6242600 0.0713293 0.4650213 0.34876419 0.11488525
> 
> 
> 
> 
> cleanEx()
> nameEx("set_priors")
> ### * set_priors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_priors
> ### Title: Set prior distribution
> ### Aliases: set_priors
> 
> ### ** Examples
> 
> 
> library(dplyr)
> model <- make_model('X -> Y') %>%
+   set_priors(alphas = 3)
> get_priors(model)
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
   3    3    3    3    3    3 
> 
> model <- make_model('X -> Y') %>%
+ set_priors(distribution = 'jeffreys')
> get_priors(model)
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
 0.5  0.5  0.5  0.5  0.5  0.5 
> 
> model <- make_model('X -> Y') %>%
+ set_priors(1:6)
> get_priors(model)
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
   1    2    3    4    5    6 
> model <- make_model('X -> Y') %>%
+ set_priors(node = 'Y', alphas = 2)
> get_priors(model)
 X.0  X.1 Y.00 Y.10 Y.01 Y.11 
   1    1    2    2    2    2 
> 
> 
> 
> cleanEx()
> nameEx("set_restrictions")
> ### * set_restrictions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_restrictions
> ### Title: Restrict a model
> ### Aliases: set_restrictions
> 
> ### ** Examples
> 
> 
> # 1. Restrict parameter space using statements
> model <- make_model('X->Y') %>%
+   set_restrictions(statement = c('X == 0'))
> 
> model <- make_model('X->Y') %>%
+   set_restrictions(non_increasing('X', 'Y'))
> 
> model <- make_model('X -> Y <- W') %>%
+   set_restrictions(c(decreasing('X', 'Y'), substitutes('X', 'W', 'Y')))
> 
> model$parameters_df
   param_names param_value param_set node nodal_type gen priors
1          W.0   0.5000000         W    W          0   1      1
2          W.1   0.5000000         W    W          1   1      1
3          X.0   0.5000000         X    X          0   2      1
4          X.1   0.5000000         X    X          1   2      1
5       Y.0000   0.1428571         Y    Y       0000   3      1
6       Y.1010   0.1428571         Y    Y       1010   3      1
7       Y.0001   0.1428571         Y    Y       0001   3      1
8       Y.0101   0.1428571         Y    Y       0101   3      1
9       Y.0011   0.1428571         Y    Y       0011   3      1
10      Y.1011   0.1428571         Y    Y       1011   3      1
11      Y.1111   0.1428571         Y    Y       1111   3      1
> 
> model <- make_model('X-> Y <- W') %>%
+   set_restrictions(statement = decreasing('X', 'Y'))
> model$parameters_df
   param_names param_value param_set node nodal_type gen priors
1          W.0   0.5000000         W    W          0   1      1
2          W.1   0.5000000         W    W          1   1      1
3          X.0   0.5000000         X    X          0   2      1
4          X.1   0.5000000         X    X          1   2      1
5       Y.0000   0.1111111         Y    Y       0000   3      1
6       Y.0010   0.1111111         Y    Y       0010   3      1
7       Y.1010   0.1111111         Y    Y       1010   3      1
8       Y.0001   0.1111111         Y    Y       0001   3      1
9       Y.0101   0.1111111         Y    Y       0101   3      1
10      Y.0011   0.1111111         Y    Y       0011   3      1
11      Y.1011   0.1111111         Y    Y       1011   3      1
12      Y.0111   0.1111111         Y    Y       0111   3      1
13      Y.1111   0.1111111         Y    Y       1111   3      1
> 
> model <- make_model('X->Y') %>%
+   set_restrictions(decreasing('X', 'Y'))
> model$parameters_df
  param_names param_value param_set node nodal_type gen priors
1         X.0   0.5000000         X    X          0   1      1
2         X.1   0.5000000         X    X          1   1      1
3        Y.00   0.3333333         Y    Y         00   2      1
4        Y.01   0.3333333         Y    Y         01   2      1
5        Y.11   0.3333333         Y    Y         11   2      1
> 
> model <- make_model('X->Y') %>%
+   set_restrictions(c(increasing('X', 'Y'), decreasing('X', 'Y')))
> model$parameters_df
  param_names param_value param_set node nodal_type gen priors
1         X.0         0.5         X    X          0   1      1
2         X.1         0.5         X    X          1   1      1
3        Y.00         0.5         Y    Y         00   2      1
4        Y.11         0.5         Y    Y         11   2      1
> 
> # Restrict to define a model with monotonicity
> model <- make_model('X->Y') %>%
+ set_restrictions(statement = c('Y[X=1] < Y[X=0]'))
> get_parameter_matrix(model)
     X0.Y00 X1.Y00 X0.Y01 X1.Y01 X0.Y11 X1.Y11
X.0       1      0      1      0      1      0
X.1       0      1      0      1      0      1
Y.00      1      1      0      0      0      0
Y.01      0      0      1      1      0      0
Y.11      0      0      0      0      1      1
> 
> # Restrict to a single type in endogenous node
> model <- make_model('X->Y') %>%
+ set_restrictions(statement =  '(Y[X = 1] == 1)', join_by = '&', keep = TRUE)
> get_parameter_matrix(model)
     X0.Y01 X1.Y01 X0.Y11 X1.Y11
X.0       1      0      1      0
X.1       0      1      0      1
Y.01      1      1      0      0
Y.11      0      0      1      1
> 
> #  Use of | and &
> # Keep node if *for some value of B* Y[A = 1] == 1
> model <- make_model('A->Y<-B') %>%
+ set_restrictions(statement =  '(Y[A = 1] == 1)', join_by = '|', keep = TRUE)
> dim(get_parameter_matrix(model))
[1] 16 48
> 
> 
> # Keep node if *for all values of B* Y[A = 1] == 1
> model <- make_model('A->Y<-B') %>%
+ set_restrictions(statement =  '(Y[A = 1] == 1)', join_by = '&', keep = TRUE)
> dim(get_parameter_matrix(model))
[1]  8 16
> 
> # Restrict multiple nodes
> model <- make_model('X->Y<-M; X -> M' ) %>%
+ set_restrictions(statement =  c('(Y[X = 1] == 1)', '(M[X = 1] == 1)'), join_by = '&', keep = TRUE)
> get_parameter_matrix(model)
       X0.M01.Y0101 X1.M01.Y0101 X0.M11.Y0101 X1.M11.Y0101 X0.M01.Y1101
X.0               1            0            1            0            1
X.1               0            1            0            1            0
M.01              1            1            0            0            1
M.11              0            0            1            1            0
Y.0101            1            1            1            1            0
Y.1101            0            0            0            0            1
Y.0111            0            0            0            0            0
Y.1111            0            0            0            0            0
       X1.M01.Y1101 X0.M11.Y1101 X1.M11.Y1101 X0.M01.Y0111 X1.M01.Y0111
X.0               0            1            0            1            0
X.1               1            0            1            0            1
M.01              1            0            0            1            1
M.11              0            1            1            0            0
Y.0101            0            0            0            0            0
Y.1101            1            1            1            0            0
Y.0111            0            0            0            1            1
Y.1111            0            0            0            0            0
       X0.M11.Y0111 X1.M11.Y0111 X0.M01.Y1111 X1.M01.Y1111 X0.M11.Y1111
X.0               1            0            1            0            1
X.1               0            1            0            1            0
M.01              0            0            1            1            0
M.11              1            1            0            0            1
Y.0101            0            0            0            0            0
Y.1101            0            0            0            0            0
Y.0111            1            1            0            0            0
Y.1111            0            0            1            1            1
       X1.M11.Y1111
X.0               0
X.1               1
M.01              0
M.11              1
Y.0101            0
Y.1101            0
Y.0111            0
Y.1111            1
> 
> # Restrictions on levels for endogenous nodes aren't allowed
> ## Not run: 
> ##D model <- make_model('X->Y') %>%
> ##D set_restrictions(statement =  '(Y == 1)')
> ## End(Not run)
> 
> # 2. Restrict parameter space Using labels:
> model <- make_model('X->Y') %>%
+ set_restrictions(labels = list(X = '0', Y = '00'))
> 
> # Restrictions can be  with wildcards
> model <- make_model('X->Y') %>%
+ set_restrictions(labels = list(Y = '?0'))
> get_parameter_matrix(model)
     X0.Y01 X1.Y01 X0.Y11 X1.Y11
X.0       1      0      1      0
X.1       0      1      0      1
Y.01      1      1      0      0
Y.11      0      0      1      1
> 
> # Running example: there are only four causal types
> model <- make_model('S -> C -> Y <- R <- X; X -> C -> R') %>%
+ set_restrictions(labels = list(C = '1000', R = '0001', Y = '0001'), keep = TRUE)
> get_parameter_matrix(model)
       S0.X0.C1000.R0001.Y0001 S1.X0.C1000.R0001.Y0001 S0.X1.C1000.R0001.Y0001
S.0                          1                       0                       1
S.1                          0                       1                       0
X.0                          1                       1                       0
X.1                          0                       0                       1
C.1000                       1                       1                       1
R.0001                       1                       1                       1
Y.0001                       1                       1                       1
       S1.X1.C1000.R0001.Y0001
S.0                          0
S.1                          1
X.0                          0
X.1                          1
C.1000                       1
R.0001                       1
Y.0001                       1
> 
> 
> 
> 
> cleanEx()
> nameEx("simulate_data")
> ### * simulate_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate_data
> ### Title: simulate_data is an alias for make_data
> ### Aliases: simulate_data
> 
> ### ** Examples
> 
> simulate_data(make_model("X->Y"))
  X Y
1 0 1
> 
> 
> 
> cleanEx()
> nameEx("simulate_events")
> ### * simulate_events
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate_events
> ### Title: Draw compact data
> ### Aliases: simulate_events
> 
> ### ** Examples
> 
> model <- make_model('X -> Y')
> simulate_events(model = model)
  event count
1  X0Y0     0
2  X1Y0     0
3  X0Y1     1
4  X1Y1     0
> simulate_events(model = model, param_type = 'prior_draw')
  event count
1  X0Y0     0
2  X1Y0     1
3  X0Y1     0
4  X1Y1     0
> simulate_events(model = model, include_strategy = TRUE)
  event strategy count
1  X0Y0       XY     1
2  X1Y0       XY     0
3  X0Y1       XY     0
4  X1Y1       XY     0
> 
> 
> 
> 
> cleanEx()
> nameEx("st_within")
> ### * st_within
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: st_within
> ### Title: Get string between two regular expression patterns
> ### Aliases: st_within
> 
> ### ** Examples
> 
> a <- '(XX[Y=0] == 1) > (XX[Y=1] == 0)'
> st_within(a)
[1] "XX" "XX"
> b <- '(XXX[[Y=0]] == 1 + XXX[[Y=1]] == 0)'
> st_within(b)
[1] "XXX" "XXX"
> 
> 
> 
> cleanEx()
> nameEx("substitutes")
> ### * substitutes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: substitutes
> ### Title: Make statement for substitutes
> ### Aliases: substitutes
> 
> ### ** Examples
> 
> 
> get_query_types(model = make_model('A -> B <- C'),
+          query = substitutes('A', 'C', 'B'))

Causal types satisfying query's condition(s)  

 query =  ((B[A = 1, C = 1]) - (B[A = 0, C = 1])) < ((B[A = 1, C = 0]) - (B[A = 0, C = 0])) 

A0.C0.B0100  A1.C0.B0100
A0.C1.B0100  A1.C1.B0100
A0.C0.B0010  A1.C0.B0010
A0.C1.B0010  A1.C1.B0010
A0.C0.B0110  A1.C0.B0110
A0.C1.B0110  A1.C1.B0110
A0.C0.B1110  A1.C0.B1110
A0.C1.B1110  A1.C1.B1110
A0.C0.B0111  A1.C0.B0111
A0.C1.B0111  A1.C1.B0111


 Number of causal types that meet condition(s) =  20
 Total number of causal types in model =  64> 
> query_model(model = make_model('A -> B <- C'),
+          queries = substitutes('A', 'C', 'B'),
+          using = 'parameters')
  Query Given      Using  mean
1   Q 1     - parameters 0.312
> 
> 
> 
> cleanEx()
> nameEx("te")
> ### * te
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: te
> ### Title: Make treatment effect statement (positive)
> ### Aliases: te
> 
> ### ** Examples
> 
> te('A', 'B')
[1] "(B[A=1] - B[A=0])"
attr(,"class")
[1] "statement"
> 
> model <- make_model('X->Y') %>% set_restrictions(increasing('X', 'Y'))
> query_model(model, list(ate = te('X', 'Y')),  using = 'parameters')
  Query Given      Using   mean
1   ate     - parameters -0.333
> 
> # set_restrictions  breaks with te because it requires a listing
> # of causal types, not numeric output.
> ## Not run: 
> ##D model <- make_model('X->Y') %>% set_restrictions(te('X', 'Y'))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("translate_dagitty")
> ### * translate_dagitty
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: translate_dagitty
> ### Title: Puts your DAG into daggity syntax (useful for using their
> ###   plotting functions)
> ### Aliases: translate_dagitty
> 
> ### ** Examples
> 
> ## Not run: 
> ##D model <- make_model('X -> Y')
> ##D translate_dagitty(model)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("update_causal_types")
> ### * update_causal_types
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update_causal_types
> ### Title: Update causal types based on nodal types
> ### Aliases: update_causal_types
> 
> ### ** Examples
> 
> update_causal_types(make_model('X->Y'))
       X  Y
X0.Y00 0 00
X1.Y00 1 00
X0.Y10 0 10
X1.Y10 1 10
X0.Y01 0 01
X1.Y01 1 01
X0.Y11 0 11
X1.Y11 1 11
> 
> 
> 
> cleanEx()
> nameEx("update_model")
> ### * update_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update_model
> ### Title: Fit causal model using stan
> ### Aliases: update_model
> 
> ### ** Examples
> 
> model <- make_model('X->Y')
> data_long   <- simulate_data(model, n = 4)
> data_short  <- collapse_data(data_long, model)
> model_1 <- update_model(model, data_long)

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 0 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.097 seconds (Warm-up)
Chain 1:                0.108 seconds (Sampling)
Chain 1:                0.205 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 0 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.106 seconds (Warm-up)
Chain 2:                0.095 seconds (Sampling)
Chain 2:                0.201 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 0 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.098 seconds (Warm-up)
Chain 3:                0.136 seconds (Sampling)
Chain 3:                0.234 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 0 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.107 seconds (Warm-up)
Chain 4:                0.08 seconds (Sampling)
Chain 4:                0.187 seconds (Total)
Chain 4: 
> 
> # Throws error unless compact data indicated:
> ## Not run: 
> ##D model_3 <- update_model(model, data_short)
> ## End(Not run)
> model_4 <- update_model(model, data_short, data_type = 'compact')

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 0 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.092 seconds (Warm-up)
Chain 1:                0.085 seconds (Sampling)
Chain 1:                0.177 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 0 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.098 seconds (Warm-up)
Chain 2:                0.089 seconds (Sampling)
Chain 2:                0.187 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 0 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.092 seconds (Warm-up)
Chain 3:                0.091 seconds (Sampling)
Chain 3:                0.183 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 0 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.093 seconds (Warm-up)
Chain 4:                0.091 seconds (Sampling)
Chain 4:                0.184 seconds (Total)
Chain 4: 
> 
> # It is possible to implement updating without data, in which case the posterior
> # is a stan object that reflects the prior
> model5 <- update_model(model)
No data provided

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 0 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.084 seconds (Warm-up)
Chain 1:                0.081 seconds (Sampling)
Chain 1:                0.165 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 0 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.09 seconds (Warm-up)
Chain 2:                0.059 seconds (Sampling)
Chain 2:                0.149 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 0 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.083 seconds (Warm-up)
Chain 3:                0.098 seconds (Sampling)
Chain 3:                0.181 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'simplexes' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 0 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.084 seconds (Warm-up)
Chain 4:                0.089 seconds (Sampling)
Chain 4:                0.173 seconds (Total)
Chain 4: 
> 
> # Advanced: Example of a model with tailored parameters.
> # We take a model and add a tailored P matrix (which maps from parameters
> # to causal types) and a tailored parameters_df which reports that
> # all parameters are in one family.
> # Parameters in this example are not connected with nodal types in any way.
> 
> ## Not run: 
> ##D model <- make_model('X->Y')
> ##D model$P <- diag(8)
> ##D colnames(model$P) <- rownames(model$causal_types)
> ##D model$parameters_df <- data.frame(
> ##D   param_names = paste0('x',1:8),
> ##D   param_set = 1, priors = 1, parameters = 1/8)
> ##D 
> ##D # Update fully confounded model on strongly correlated data
> ##D 
> ##D data <- make_data(make_model('X->Y'), n = 100,
> ##D   parameters = c(.5, .5, .1,.1,.7,.1))
> ##D fully_confounded <- update_model(model, data, keep_fit = TRUE)
> ##D fully_confounded$stan_fit
> ##D query_model(fully_confounded, 'Y[X = 1] > Y[X=0]', using = 'posteriors')
> ##D # To see the confounding:
> ##D with(fully_confounded$posterior_distribution %>% data.frame(),
> ##D {par(mfrow = c(1,2))
> ##D  plot(x1, x5, main = 'joint distribution of X0.Y00, X0.Y01')
> ##D  plot(x1, x6, main = 'joint distribution of X0.Y00, X1.Y01')})
> ## End(Not run)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  24.07 0.31 24.36 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
